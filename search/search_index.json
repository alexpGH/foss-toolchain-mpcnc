{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A set of tutorials around foss 1 tools for the mpcnc 2 1) free and open source 2) mostly printed cnc The related discussion can be found in the forum WARNING I\u2019m no expert in all of this. Try at your own risk! This is work in progress and will be extended bit by bit. Overview of tutorials Nr. Title Description 1 Freecad part 1 From zero \u2192 gcode; Get FreeCAD, design a pocket with island, export gcode 2 Controller board, firmware Controller board & firmware options 3 ZOOM: controller & firmware option B) grbl on ramps for dual end stop based auto squaring 4 bCnC Get, configure and get started with bCNC 5 Milling part 1 Milling the part from tutorial 1 6 Freecad part 1+ Configuring to sensible settings, adding finish pass and holding tags Motivation I really like open source stuff, and I\u2019m quite impressed by Ryan & folks. I have build my own mpcnc and want to contribute my part to the V1 universe . I think the open design & open source approach is quite powerful; I dislike to depend on closed source software which does not natively run on my favorite operating system (linux). I think paying license fee for CAM software is OK, because providing such a software is much work. For me, I decided against it for several reasons. Due to the complexity of the matter for newcomers, default tools are typically not replaced by standard users. Although there are a bunch of people operating the mpcnc & related machines with foss, and great solutions out there (see the tutorials below touching some of them), it took me several hours of reading, testing and playing around to combine the various bits of information to a consistent solution for me. Therefore I decided to provide an easy to follow, step by step guide to a foss toolchain for the mpcnc, with the aim to be applicable using linux, windows and macos. I hope you can follow all of this; if not, feel free to ask in the related thread . A bold thank you goes out to Ryan and all the other people (e.g. from FreeCAD, debian, grbl, bCNC) out there, for sharing their expertise with us! The goal Get generated gbrl gcode \u2018from zero\u2019 using Freecad (get it, do the design, path generation, gcode export) for the shown geometry. It has the features: pocket with island and finish allowance which I think shows most of the necassary basics. We will later add more complex stuff (see the to do list).","title":"Home"},{"location":"#a-set-of-tutorials-around-foss1-tools-for-the-mpcnc2","text":"1) free and open source 2) mostly printed cnc The related discussion can be found in the forum WARNING I\u2019m no expert in all of this. Try at your own risk! This is work in progress and will be extended bit by bit.","title":"A set of tutorials around foss1 tools for the mpcnc2"},{"location":"#overview-of-tutorials","text":"Nr. Title Description 1 Freecad part 1 From zero \u2192 gcode; Get FreeCAD, design a pocket with island, export gcode 2 Controller board, firmware Controller board & firmware options 3 ZOOM: controller & firmware option B) grbl on ramps for dual end stop based auto squaring 4 bCnC Get, configure and get started with bCNC 5 Milling part 1 Milling the part from tutorial 1 6 Freecad part 1+ Configuring to sensible settings, adding finish pass and holding tags","title":"Overview of tutorials"},{"location":"#motivation","text":"I really like open source stuff, and I\u2019m quite impressed by Ryan & folks. I have build my own mpcnc and want to contribute my part to the V1 universe . I think the open design & open source approach is quite powerful; I dislike to depend on closed source software which does not natively run on my favorite operating system (linux). I think paying license fee for CAM software is OK, because providing such a software is much work. For me, I decided against it for several reasons. Due to the complexity of the matter for newcomers, default tools are typically not replaced by standard users. Although there are a bunch of people operating the mpcnc & related machines with foss, and great solutions out there (see the tutorials below touching some of them), it took me several hours of reading, testing and playing around to combine the various bits of information to a consistent solution for me. Therefore I decided to provide an easy to follow, step by step guide to a foss toolchain for the mpcnc, with the aim to be applicable using linux, windows and macos. I hope you can follow all of this; if not, feel free to ask in the related thread . A bold thank you goes out to Ryan and all the other people (e.g. from FreeCAD, debian, grbl, bCNC) out there, for sharing their expertise with us!","title":"Motivation"},{"location":"#the-goal","text":"Get generated gbrl gcode \u2018from zero\u2019 using Freecad (get it, do the design, path generation, gcode export) for the shown geometry. It has the features: pocket with island and finish allowance which I think shows most of the necassary basics. We will later add more complex stuff (see the to do list).","title":"The goal"},{"location":"aeroEqn/","text":"Basic aerodynamic equations I collect here some basic equatin wich we need e.g. for airfoil dimensioning. Total lift force \\[ \\begin{equation} F_{L}=\\frac{1}{2}\\rho v^2 c_{L} S=m_{plane} \\cdot g \\label{eq:liftForce1} \\end{equation} \\] with \\(F_{L}\\) : lift force (N) \\(\\rho\\) : denisty of air (we typ. use 1.1673 kg/m\u00b3 at 500m) \\(v\\) : velocity (of the plane, m/s) \\(c_{L}\\) : total lift coefficient \\(S\\) : projected surface (m\u00b2) We use large letters as indices, e.g. \\(F_{L}\\) and \\(c_{L}\\) to indicate total (integrated over the whole wing) values in contrast to local values (e.g. given for a wing section). Stall velocity We regularly need to determine the lowest velocity, a plane can be flown without loosing height. Therefore, we resolve \\(\\eqref{eq:liftForce1}\\) for \\(v\\) : \\[ \\begin{equation} v=\\sqrt{\\frac{2\\cdot m_{plane}\\cdot g}{\\rho c_{L} S}}\\label{eq:velocityFromMass} \\end{equation} \\] Reynolds number \\[ \\begin{equation} Re=\\frac{\\rho \\cdot v \\cdot ch}{\\mu}=\\frac{v\\cdot ch}{\\nu} \\label{eq:reynolds} \\end{equation} \\] with \\(\\mu\\) : dynamic viscosity \\(\\nu\\) : kinematic viscosity of air (we typ. use 1.52 E-05 m\u00b2/s at 500m) ResqrtCl Solving \\(\\eqref{eq:reynolds}\\) for \\(v\\) , insertion in \\(\\eqref{eq:liftForce1}\\) and grouping the terms gives: \\[ \\begin{equation} \\underbrace{F_{L}=m_{plane\\cdot g}}_{const_1} =\\underbrace{\\frac{1}{2}\\rho \\frac{\\nu^2\\cdot S}{ch^2}}_{const!} \\cdot \\underbrace{Re^2\\cdot C_{L}}_{\\Rightarrow const} \\label{eq:resqrtcl1} \\end{equation} \\] First, we note that, in horicontal flight, the lift force needs to be constant ( \\(const_1\\) ). For higher velocities \\(v\\) we require less \\(C_l\\) and vice versa. All the values aggregated as \\(const!\\) are definitely constant. From this follows that \\(Re^2\\cdot C_{L}\\) needs to be constant, too. Hence: \\[ \\begin{equation} Re\\cdot\\sqrt{C_{L}}=const \\mid_{horicontal\\ flight} \\label{eq:resqrtcl2} \\end{equation} \\] Note: at a given wing section we have local values (small indices) \\[ \\begin{equation} Re\\cdot\\sqrt{C_{l}}=const \\mid_{@wing\\ section,\\ horicontal\\ flight} \\label{eq:resqrtcl3} \\end{equation} \\]","title":"Basic equations"},{"location":"aeroEqn/#basic-aerodynamic-equations","text":"I collect here some basic equatin wich we need e.g. for airfoil dimensioning.","title":"Basic aerodynamic equations"},{"location":"aeroEqn/#total-lift-force","text":"\\[ \\begin{equation} F_{L}=\\frac{1}{2}\\rho v^2 c_{L} S=m_{plane} \\cdot g \\label{eq:liftForce1} \\end{equation} \\] with \\(F_{L}\\) : lift force (N) \\(\\rho\\) : denisty of air (we typ. use 1.1673 kg/m\u00b3 at 500m) \\(v\\) : velocity (of the plane, m/s) \\(c_{L}\\) : total lift coefficient \\(S\\) : projected surface (m\u00b2) We use large letters as indices, e.g. \\(F_{L}\\) and \\(c_{L}\\) to indicate total (integrated over the whole wing) values in contrast to local values (e.g. given for a wing section).","title":"Total lift force"},{"location":"aeroEqn/#stall-velocity","text":"We regularly need to determine the lowest velocity, a plane can be flown without loosing height. Therefore, we resolve \\(\\eqref{eq:liftForce1}\\) for \\(v\\) : \\[ \\begin{equation} v=\\sqrt{\\frac{2\\cdot m_{plane}\\cdot g}{\\rho c_{L} S}}\\label{eq:velocityFromMass} \\end{equation} \\]","title":"Stall velocity"},{"location":"aeroEqn/#reynolds-number","text":"\\[ \\begin{equation} Re=\\frac{\\rho \\cdot v \\cdot ch}{\\mu}=\\frac{v\\cdot ch}{\\nu} \\label{eq:reynolds} \\end{equation} \\] with \\(\\mu\\) : dynamic viscosity \\(\\nu\\) : kinematic viscosity of air (we typ. use 1.52 E-05 m\u00b2/s at 500m)","title":"Reynolds number"},{"location":"aeroEqn/#resqrtcl","text":"Solving \\(\\eqref{eq:reynolds}\\) for \\(v\\) , insertion in \\(\\eqref{eq:liftForce1}\\) and grouping the terms gives: \\[ \\begin{equation} \\underbrace{F_{L}=m_{plane\\cdot g}}_{const_1} =\\underbrace{\\frac{1}{2}\\rho \\frac{\\nu^2\\cdot S}{ch^2}}_{const!} \\cdot \\underbrace{Re^2\\cdot C_{L}}_{\\Rightarrow const} \\label{eq:resqrtcl1} \\end{equation} \\] First, we note that, in horicontal flight, the lift force needs to be constant ( \\(const_1\\) ). For higher velocities \\(v\\) we require less \\(C_l\\) and vice versa. All the values aggregated as \\(const!\\) are definitely constant. From this follows that \\(Re^2\\cdot C_{L}\\) needs to be constant, too. Hence: \\[ \\begin{equation} Re\\cdot\\sqrt{C_{L}}=const \\mid_{horicontal\\ flight} \\label{eq:resqrtcl2} \\end{equation} \\] Note: at a given wing section we have local values (small indices) \\[ \\begin{equation} Re\\cdot\\sqrt{C_{l}}=const \\mid_{@wing\\ section,\\ horicontal\\ flight} \\label{eq:resqrtcl3} \\end{equation} \\]","title":"ResqrtCl"},{"location":"bcnc_1/","text":"bCNC: control your machine bCnc - as the authors claim: GRBL CNC command sender, autoleveler, g-code editor, digitizer, CAM and swiss army knife for all your CNC needs. This is not exaggeration - and the bets is: due to being written in python, you can use it under every operating system supporting python! Step 1 - prepare install python on your system later connected to your controller (via usb) install the python packages python-tk , python-pip install bCNC using pip from your command line # on linux systems apt-get install python python-tk python-pip pip install bcnc On windows follow these instructions . Step 2 - connect your machine to bCNC power on your controller, connect via usb on the command line python -m bCNC you should see Your machine is not connected yet. Now: fill out Port (left, mid in the Serial section). This is just what you used to flash the firmware, in my case /dev/ttyUSB0 you can chekc connect on startup if you like keep Controller : GRBL1 for now (we will check this next) hit open . You should now have: your machine is connected (the usb plug symbol is shaded in green) we are in alarm state. This is intended as far as I have understood. You need to clear this state explicitly. It prevents you from mistakenly damage your machine while not being aware of what you are doing. Step 3 - check configuration basics on the upper right click on Terminal in the left column below Alarm there is now the Command input (right at the bottom). in the the mid you see the output of grbl (the result of your commands) grbl starts with reporting the current version of firmware running on your controller - in my case Grbl1.1i - so no need to change the controller version field in the 'Serial' pane. ONLY if you are running on **an older version** e.g. grbl 0.9x: - hit File on the topmost menue - re-click the usb adapter symbol to diconnect - select a matching controller version - reconnect Please check the follwoing configuration carfully and adapt accordingly! the greeting message also tells us how to unlock the machine: $X to unlock - don't do it now! on the command promt enter $$ , hit enter: in the output pane, we now have all the settings stored on your controller in the EEPROM (persitent for power off/on) Step 4 - detailed configuration \u2192 $x=what_you_need Preamble We are focusing here on the gantry setup having dual motors per axis x (x & xc) and y (y & yc) - don't remember? check again here . Default grbl uses only 3 axis and bCNC in his machine settings interface supports only 3 axis \u2192 ignore CAM>config . Use the command line or CAM>controller interface to configure your machine settings. This is the working configuration ( available on on my git hub ) we will work through in the following. To copy a setting to your machine - just copy & paste to the command promt line by line. WARNING: although grbl stores the settings in the EEPROM and should apply them immediately, I sometimes needed to power off/on the controller for the (correctly reported settings - check by $$) have been effective! We will go through the most important settings in the following. All settings not explicitly discussed can just be copied over. Have a read in the grbl docu for detailed information. Step direction - $3 $3=val where val encodes which axis to be inverted. See the following table how to calculate val. I have the default mpcnc wiring. Surprisingly, I ended up (4th row) with a quite different setting from what would be expected (3rd row). |:-------------|:-------------:-------------:-------------:------------- | value contribution |2\u2074=16|2\u00b3=8|2\u00b2=4|2\u00b9=2|2\u2070=1| | axis |yc|xc|z|y|x| | what we would expect =24|1|1|0|0|0| | what I endded up with =21|1|0|1|0|1| So how can we safely determine that?: - on the to menue, select Control - use $$ to check that you have $5=0; if not issue $5=0 - in the command prompt enter $X (clears the alarm and should unlock the machine\u2192Idle) If you can't achieve the Idle state, you most probably have an end stop related alarm, e.g. [xyzxy], which means you misconfigured your pins \u2192 recheck your understanding & config - set the stepwidth to a small value (as indicated by the red mark) set all axis to not inverted: issue $3=0 for all axis (one after the other): make a small step note which part of the axis moves opposite to what you want place a 1 in the related column of the table shown above, add up and set $3=newSum until the axis moves as you expect when done, your machine should move as you expect (regarding the directions) Working area - $130ff My mpcnc's working area is 911x571x125(x,y,z)mm, so I use these settings: $130=911.000 (x max travel, mm) $131=571.000 (y max travel, mm) $132=125.000 (z max travel, mm) $133=911.000 (xcloned max travel, mm) $134=571.000 (ycloned max travel, mm) Make sure to have symmetric settings for x/xc and y/yc! Are you wondering why I use 911 and 571 instead of 910 and 570? This is because the homing debounce distance (which we'll set to 1mm) will be subtracted from these values and I'd like to see the 910 and 570 in the displays later on. Acceleration - $120ff I have a large build and a heavy spindle (dont't follow my example in this regard except you know what you are doing!). I therefore prefer quite low acceleration on x and y: $120=50.000 (x accel, mm/sec^2) $121=50.000 (y accel, mm/sec^2) $122=50.000 (z accel, mm/sec^2) $123=50.000 (xcloned accel, mm/sec^2) $124=50.000 (ycloned accel, mm/sec^2) Start from these values. You might be able to increase them by a factor of 4 (test it carefully). Remember to have x/xc and y/yc exactly symmetric! Max rate - $110ff Not much to say here. Keep x/xc and y/yc symmetric $110=4500.000 (x max rate, mm/min) $111=4500.000 (y max rate, mm/min) $112=800.000 (z max rate, mm/min) $113=4500.000 (xcloned max rate, mm/min) $114=4500.000 (ycloned max rate, mm/min) Steps/mm - $100ff Note: Pablo published quite different settings here. I have the exact setup of the default mpcnc with the lead screw on Z and the T16 timing belts. And came up with these: $100=200.000 (x, step/mm) $101=200.000 (y, step/mm) $102=800.000 (z, step/mm) $103=200.000 (xcloned, step/mm) $104=200.000 (ycloned, step/mm) to check these, I insert a needle the 1mm clamp of the spindle, put a metal tape measure along one axis (e.g. x), position the neddle at axis_min, travel a specific length and check what the actual travel lenght was. recalculate the steps/mm from this power on/off the board; I sometimes had issues not doing this especially for these settings Homing - $23 ff If you made it this far, your machine moves the desired distances in the right directions. $23 is the homing dir invert; i have $23=31 which means all axes inverted |:-------------|:-------------:-------------:-------------:------------- | value contribution |2\u2074=16|2\u00b3=8|2\u00b2=4|2\u00b9=2|2\u2070=1| | axis |yc|xc|z|y|x| | defaultmpcnc =31|1|1|1|1|1| and puts home to the lower left of your machine - that's the mpcnc standard. Note: the machine should home x and y axis, and leave z as it is. This behaviour can be configured in config.h l.153 and 154 if you'd like to change it. You need to recompile / flash in case you changed it. Next: - trigger each end stop manually and see if it gets displayed as intended (I triggered the x end stop for the following screenshot - note the Idle [x] status, not triggering the end stop, the [x] should disappear again) when all end stops act as intended: hands on the emergency off enter $H to start the homing sequence if anything is not as intended, emergency stop the machine if everything went well, the homing procedure places the machine at the configured homing pull of distance away from the endstops ($27=1.000 mm) The lower left position in grbl as with professional cnc machines, is always negative working area distance; in my case: -901/-570 That's it! I suggest you learn about G54 - G59 if you don't already know whats that. And get familiar with sending gcode files to your machine. Have fun! Feel free to dicuss your questions in the related discussion thread","title":"bCNC"},{"location":"bcnc_1/#bcnc-control-your-machine","text":"bCnc - as the authors claim: GRBL CNC command sender, autoleveler, g-code editor, digitizer, CAM and swiss army knife for all your CNC needs. This is not exaggeration - and the bets is: due to being written in python, you can use it under every operating system supporting python!","title":"bCNC: control your machine"},{"location":"bcnc_1/#step-1-prepare","text":"install python on your system later connected to your controller (via usb) install the python packages python-tk , python-pip install bCNC using pip from your command line # on linux systems apt-get install python python-tk python-pip pip install bcnc On windows follow these instructions .","title":"Step 1 - prepare"},{"location":"bcnc_1/#step-2-connect-your-machine-to-bcnc","text":"power on your controller, connect via usb on the command line python -m bCNC you should see Your machine is not connected yet. Now: fill out Port (left, mid in the Serial section). This is just what you used to flash the firmware, in my case /dev/ttyUSB0 you can chekc connect on startup if you like keep Controller : GRBL1 for now (we will check this next) hit open . You should now have: your machine is connected (the usb plug symbol is shaded in green) we are in alarm state. This is intended as far as I have understood. You need to clear this state explicitly. It prevents you from mistakenly damage your machine while not being aware of what you are doing.","title":"Step 2 - connect your machine to bCNC"},{"location":"bcnc_1/#step-3-check-configuration-basics","text":"on the upper right click on Terminal in the left column below Alarm there is now the Command input (right at the bottom). in the the mid you see the output of grbl (the result of your commands) grbl starts with reporting the current version of firmware running on your controller - in my case Grbl1.1i - so no need to change the controller version field in the 'Serial' pane. ONLY if you are running on **an older version** e.g. grbl 0.9x: - hit File on the topmost menue - re-click the usb adapter symbol to diconnect - select a matching controller version - reconnect Please check the follwoing configuration carfully and adapt accordingly! the greeting message also tells us how to unlock the machine: $X to unlock - don't do it now! on the command promt enter $$ , hit enter: in the output pane, we now have all the settings stored on your controller in the EEPROM (persitent for power off/on)","title":"Step 3 - check configuration basics"},{"location":"bcnc_1/#step-4-detailed-configuration-xwhat_you_need","text":"","title":"Step 4 - detailed configuration &#8594; $x=what_you_need"},{"location":"bcnc_1/#preamble","text":"We are focusing here on the gantry setup having dual motors per axis x (x & xc) and y (y & yc) - don't remember? check again here . Default grbl uses only 3 axis and bCNC in his machine settings interface supports only 3 axis \u2192 ignore CAM>config . Use the command line or CAM>controller interface to configure your machine settings. This is the working configuration ( available on on my git hub ) we will work through in the following. To copy a setting to your machine - just copy & paste to the command promt line by line. WARNING: although grbl stores the settings in the EEPROM and should apply them immediately, I sometimes needed to power off/on the controller for the (correctly reported settings - check by $$) have been effective! We will go through the most important settings in the following. All settings not explicitly discussed can just be copied over. Have a read in the grbl docu for detailed information.","title":"Preamble"},{"location":"bcnc_1/#step-direction-3","text":"$3=val where val encodes which axis to be inverted. See the following table how to calculate val. I have the default mpcnc wiring. Surprisingly, I ended up (4th row) with a quite different setting from what would be expected (3rd row). |:-------------|:-------------:-------------:-------------:------------- | value contribution |2\u2074=16|2\u00b3=8|2\u00b2=4|2\u00b9=2|2\u2070=1| | axis |yc|xc|z|y|x| | what we would expect =24|1|1|0|0|0| | what I endded up with =21|1|0|1|0|1| So how can we safely determine that?: - on the to menue, select Control - use $$ to check that you have $5=0; if not issue $5=0 - in the command prompt enter $X (clears the alarm and should unlock the machine\u2192Idle) If you can't achieve the Idle state, you most probably have an end stop related alarm, e.g. [xyzxy], which means you misconfigured your pins \u2192 recheck your understanding & config - set the stepwidth to a small value (as indicated by the red mark) set all axis to not inverted: issue $3=0 for all axis (one after the other): make a small step note which part of the axis moves opposite to what you want place a 1 in the related column of the table shown above, add up and set $3=newSum until the axis moves as you expect when done, your machine should move as you expect (regarding the directions)","title":"Step direction - $3"},{"location":"bcnc_1/#working-area-130ff","text":"My mpcnc's working area is 911x571x125(x,y,z)mm, so I use these settings: $130=911.000 (x max travel, mm) $131=571.000 (y max travel, mm) $132=125.000 (z max travel, mm) $133=911.000 (xcloned max travel, mm) $134=571.000 (ycloned max travel, mm) Make sure to have symmetric settings for x/xc and y/yc! Are you wondering why I use 911 and 571 instead of 910 and 570? This is because the homing debounce distance (which we'll set to 1mm) will be subtracted from these values and I'd like to see the 910 and 570 in the displays later on.","title":"Working area - $130ff"},{"location":"bcnc_1/#acceleration-120ff","text":"I have a large build and a heavy spindle (dont't follow my example in this regard except you know what you are doing!). I therefore prefer quite low acceleration on x and y: $120=50.000 (x accel, mm/sec^2) $121=50.000 (y accel, mm/sec^2) $122=50.000 (z accel, mm/sec^2) $123=50.000 (xcloned accel, mm/sec^2) $124=50.000 (ycloned accel, mm/sec^2) Start from these values. You might be able to increase them by a factor of 4 (test it carefully). Remember to have x/xc and y/yc exactly symmetric!","title":"Acceleration - $120ff"},{"location":"bcnc_1/#max-rate-110ff","text":"Not much to say here. Keep x/xc and y/yc symmetric $110=4500.000 (x max rate, mm/min) $111=4500.000 (y max rate, mm/min) $112=800.000 (z max rate, mm/min) $113=4500.000 (xcloned max rate, mm/min) $114=4500.000 (ycloned max rate, mm/min)","title":"Max rate - $110ff"},{"location":"bcnc_1/#stepsmm-100ff","text":"Note: Pablo published quite different settings here. I have the exact setup of the default mpcnc with the lead screw on Z and the T16 timing belts. And came up with these: $100=200.000 (x, step/mm) $101=200.000 (y, step/mm) $102=800.000 (z, step/mm) $103=200.000 (xcloned, step/mm) $104=200.000 (ycloned, step/mm) to check these, I insert a needle the 1mm clamp of the spindle, put a metal tape measure along one axis (e.g. x), position the neddle at axis_min, travel a specific length and check what the actual travel lenght was. recalculate the steps/mm from this power on/off the board; I sometimes had issues not doing this especially for these settings","title":"Steps/mm  - $100ff"},{"location":"bcnc_1/#homing-23-ff","text":"If you made it this far, your machine moves the desired distances in the right directions. $23 is the homing dir invert; i have $23=31 which means all axes inverted |:-------------|:-------------:-------------:-------------:------------- | value contribution |2\u2074=16|2\u00b3=8|2\u00b2=4|2\u00b9=2|2\u2070=1| | axis |yc|xc|z|y|x| | defaultmpcnc =31|1|1|1|1|1| and puts home to the lower left of your machine - that's the mpcnc standard. Note: the machine should home x and y axis, and leave z as it is. This behaviour can be configured in config.h l.153 and 154 if you'd like to change it. You need to recompile / flash in case you changed it. Next: - trigger each end stop manually and see if it gets displayed as intended (I triggered the x end stop for the following screenshot - note the Idle [x] status, not triggering the end stop, the [x] should disappear again) when all end stops act as intended: hands on the emergency off enter $H to start the homing sequence if anything is not as intended, emergency stop the machine if everything went well, the homing procedure places the machine at the configured homing pull of distance away from the endstops ($27=1.000 mm) The lower left position in grbl as with professional cnc machines, is always negative working area distance; in my case: -901/-570 That's it! I suggest you learn about G54 - G59 if you don't already know whats that. And get familiar with sending gcode files to your machine. Have fun! Feel free to dicuss your questions in the related discussion thread","title":"Homing - $23 ff"},{"location":"blenderAirfoils/","text":"Why script based modelling I like script based, parametric modelling, because I can 'replay' complex design sequences with adapted parameters. Examples are my kite-hydrofoil and SUP hydrofoil front and rear wings, which follow the same design approach, with the rear wing being a smaller version of the front wing and the SUP/Wave front wing (I call it monster ) having a 3 x chordlength. Kite & SUP foils Sup/Wave foil monster wing Wonder why it look that way? Pretty easy: I use it with kite and with my SUP (withe paddle) in waves. When I was waching SUP wave videos form others (in the early days) I saw that they need to palle like crazy to get flying, get flying late, wenh the wave is already steep, then race down the slope and get far in front of the wave. In addition, I wanted to be as agile (tight curves) as with my kite-foil My design conditions therefore have been: keep the width at 70cm only (today typical SUP foils use 90cm or even larger!) get to fly at ~12km/h to catch the wave early before it gest to steep limit the max velocity via slef-limitation all in all, using a low aspect ratio (large chord relative to given spanwidth) and generating massive induced drag did the job and I'm quite pleased with the result. The basic scripts I provide my scripts at github . The folder scripts contains wingLib.py, the library holding the basic worker routines and 2D airfoil data Folder Name Comment scripts wingLib.py basic worker routines to e.g. get from 2D points to 3D surfaces scripts afData_xy.py 2D airfoil data for profile xy planes/basicWing basicWing.blend the blender file for the basic wing example planes/basicWing ellipticPlaneWing.py the python script used in the basicWing.blend file to generate a planar wing with elliptic chord I currently include the h105 profile, which I (and many others) use for hydrofoils. This will be extended bit by bit according to my needs. Feel free to add your own profile data and send me a pull request. If you are looking for a specific dataset, check out UIUC Airfoil Database . Getting started What we'll be doing: Take a set of points for a 2d profile (in this case the h105) Determine the position of the leading edge according to a parametrized curve (to achieve the seewp back of the wing tip region) Determine the chordlength along the span according to an elliptic curve Scale and place the 2D points and fit a curve through them (we then have a set of 2D profile curves placed in 3d as wing sections) Fit a surface through all the curves This gives us the 3D wing which could then be used for generating CAM paths using blenderCam. Open blender's scripting workspace Once you have blender up and running, clone the blenderCadCamTools . Start blender and open the basicWing.blend file. The reult should look like: If not, check to be on the scripting workspace - you can select the different workspace in the top menu to the right of the standard menue (File, ...). You will most probaly end-up switching between Modeling and Scripting . In the Scripting workspace, the script ellipticPlaneWing.py from the repo (stored right next to the blend file) should be open. If not, click the symbol which looks like a folder (second from right), browse to where you cloned the repo to and open planes/basicWing/ellipticPlaneWing.py Scripting tools On the left side, you have the usual modeling wintow (top) python console (middle) where you can enter python commands python commands blender uses when you model (using the mouse and user interface). This is quite helful, as you can copy paste the commands over to your scripts Now click in the modeling window (top left) and hit n to pu-up the item transform dialogue which shows the location properties of the selected object (the wing). In the field for Location Y enter 0 and hit enter. The script output window (left bottom shows the python api used to set the Y location). Select via left-click (blue), right-click>copy and paste in the python console (left middle). Change '= 0' to e.g. = 0.042 and hit enter. The wing now moved to that position: This is what we use at the end of the script (line 99) to place the wing at the origin (previous figure on the right). Take home : what you can model can be scripted. Just open the scripting workspace and have a look at the api command output. The ellipticPlaneWing.py script The first few lines import necessary libraries, then extend the path to include the blenderCadCam scripts directory. Line 10 uses a relative path (relative to the current blend file). If you cloned the repo, the scripts directory is 2 dirs up from basicWing.blend. Line 28 & 29 then imports / reloads the winLib (the reload is necessary in case the file changed during the blender session). Line 31/32 imports the h105 2d profile. Configure the if clause line 43 to 1 , 50 and 94 to 0 Hit run script (upper right of the script window). Noe the wing should have been disappeared. The deleteAll() helper routine in fact deletes all except the camera and lamp. Configure the if clause line 43 AND 50 to 1 , 94 to 0 . Run the script. You should now have a set of 2D profiles, named 2dsection_x . This is the result of executing steps 1.) to 4.) from some Configure the if clause line 43, 50 AND 94 to 1 . Run the script. This should give you the result of step 5: a surface fitted through the 2d curves. Read through the scripts, it should be pretty obvious. An important hint: the sufaces need to be closed, otherwize you will get weird errors later on (mainly when using boolean intersections for designing moulds etc.). This is done in two places: Each of the 2D curves are closed (in placeSectionsMinLimited calling curveBezierFromPoints(hCoord,name,True) True=closed curve) In bridgeListOfEdgeLoopsCloseOuterWithFace (as the name states: outer edge loop is closed with face)) Getting there took me quite some time fiddling around. It's like always: once you have it, it looks straight forward. You can now imagine how to generate bend-up wing tips etc. Either use the usual modeling tools of blender to do it once. Alternatively, define a function and adapt z location and y rotation of the individual sections before fitting the surface. Moulds can now be designed by subtracting the wing from cubes etc. Play a bit with the modeling interface, have a look at the api command output and start designing your own scripts. Adding a new 2D profile Update: The following works as described. Hwoever,in the meantime I added the possibility to directly import dat files wingLib.foilImport() , resampling wingLib.foildDataReduceToNpoints() and re-sampling for morphing of profiles wingLib.interpolateBezier2on1() . See e.g. kissSlopeWing2.py discussed below . The follwing sequence can be used to add a new 2D profile, e.g. from the airfoil database . We will be doing this for the modified MH30. a) Prepare the py file Add a new airfoild data file in the scrpts directory, e.g. afData_mh30ModPK.py b) Get data in selig format Get the data in selig format (data starts at the trailing edge, goes the over the upper half to the leading edge and back again on the lower half). The airfoiltools site provides the selig format dat file. c) Store the data as python 3D array In the afData_mh30ModPK.py, in the function coords, add the profile data for quality super , as vector, with x all 0.0 def coords(quality,scale,shiftV): if(quality=='super'): coords=scale*np.array([ [0.0,-1.000019, 0.000581], ... [0.0, -0.875281,-0.0048557]])+shiftV d) Open a blend file and helper script Take a look at planes/kissSlope/howtoAddMH30.py for the python code related to the follwoing steps. You can e.g. open planes/kissSlope/kissSlopwWing.blend and enter the scripting workspace. I included the howtoAddMH30.py there. e) Generate dataseta with reduced number of points In howtoAddMH30.py , after the default header, activate the block reduce quality . Line 49 provides the super coordinates (unscaled and unshifted) and plugs it into a routine (line 50), which reduces the number of points while keeping the error below a certain value. Try e.g. 0.0002 to reduce the 200 datapoints of the MH30 super set to ~60. Keep the last parameter to False , such that you can see the curves testcurve and Simple_testcurve after running the script. Run the sript. Inspect the curve Simple_testcurve - this is the one with reduced number of points against testcurve . The following image shows only super-small differences (where the orange sections appear). Don't be irritated by the fact that the simplified curve is not yet closed at the trailing edge: Inspect blenders stdout for the reduced dataset in 3d array style and info about the number of points and leading edge index: Update afData_mh30ModPK.py 56 Points is good for full quality -> copy over the dataset into afData_mh30ModPK.py elif(quality=='full'): coords=scale*np.array([ ... and update the leading edge idx definition for this quality: def leadingEdgeIdx(quality): ... elif(quality=='full'): idx=33 ... Check the result Activate the block Check result . L55 fetches the data for the generated quality ( full in our current example) and l.56 fits a Beziercurve as we will do when generating 3D wings. The two boolean True parameters refer to: close the curve, and generate a sharp edge where the curve is closed (the trailing edge). Run the srcipt & inspect the resulting curve estcurveFin . If it looks good, continue wit medium and low quality (I used 0.0004 and 0.0008, respectively). More complex wing design We'll be using the following files: Folder Name Comment scripts wingLib.py basic worker routines to e.g. get from 2D points to 3D surfaces planes/kissSlope kissSlopeWing.blend the blender file planes/kissSlope kissSlopeWing2.py the python script used to generate a wing with configurable deviation from elliptic chord, multiple profiles and twist angle kissSlope2.py The header and geometric definition is as usual (L 1-60). We now have the possibility to import profile dat files e.g. applied in l. 66 providing the coordinate matrix and leading edge index. wingLib.foilDataReducetoNpoints() in l.81 allows to downsample the profile data (typically, for CAM model we don't ned as much points as e.g. for aerodynamic analysis). The downsampling reduces points such that the resulting qulaity of the curve is best conserved. wingLib.interpolateBezier2on1() in l.91 interpolates the second curve at the (angular) support points of the first profile. This is required for profile morphing (fading from one profile to another in spanwise direction), as this requires the same number of support points in similar angular distribution. In this example, we use the AG25 as root profile, then fade over to AG25 and AG14 in the outer region. L.96ff illustrates how to plot the profiles for an inspecton (you should to this to ensure that downsampleing etc. worked out well). L.111 compiles a dict for easy access of the prepared profile data L.123 - 128 defines the base sections: AG25 from span 0-5%, AG26 at 40% span, AG14 from 95% span. tA is the local twist angle. In ths subsections between two basic sections, the twist angle is linear interpolated betwenn the inner and outer basic section settings. \"tMorph\":True activates profile morphing for the subsections. Options (currenly) are lS and lCh . lS linearly morphes the profile according to the relative span position of the subsection between the basic sections (e.g. a subsection right between two base sections would be 50% left and 50% right profile). lCh morphes the profile linear according to the local chordlength compared to the chordlength of the enclosing basic profiles (which approx. relates to the local Reynoldsnumber). L.137 - 141 allows to configure a spanwise deviation from the pure elliptic chord distribution as added chordlength defined at arbitrary many span positions (linear interpolated in between). In the example, the span positions match the base section definitions, this however is not necessary! The rest is as usual and result in the 3D mesh of the wing: Out & hinge line design, projected area We'll be using the following files: Folder Name Comment scripts wingLib.py basic worker routines planes/kissSlope kissSlopeWing.blend the blender file planes/kissSlope hingeLine.py the python script used to generate a sketch of the out- & hinge line hingeLine.py This is a simple script generating a beezier curve for the wing outline and a line for the hinge line like the one illustrated below: After the obligatory header and basic geometry definition, l.80ff defines the hinge line, which should be self-explanatory. The following lines then define the section-wise ch extension as dicussed above and plot the curves. The projected area can now easily be determined via: selecting the outline's curve in object mode > object > convert to mesh edit mode > select all points (hit a) > face > fill object mode > hit n to open the extended dialogue select the 4th elemnt in the vertical menue (item - tool - view - 3d print) Should the 3d print menue not show up, check to have preferences > add ons > 3d toolbox checked 3d print > hit the area button and find the area in the result field","title":"Basic python scripting 4 airfoils"},{"location":"blenderAirfoils/#why-script-based-modelling","text":"I like script based, parametric modelling, because I can 'replay' complex design sequences with adapted parameters. Examples are my kite-hydrofoil and SUP hydrofoil front and rear wings, which follow the same design approach, with the rear wing being a smaller version of the front wing and the SUP/Wave front wing (I call it monster ) having a 3 x chordlength.","title":"Why script based modelling"},{"location":"blenderAirfoils/#kite-sup-foils","text":"Sup/Wave foil monster wing Wonder why it look that way? Pretty easy: I use it with kite and with my SUP (withe paddle) in waves. When I was waching SUP wave videos form others (in the early days) I saw that they need to palle like crazy to get flying, get flying late, wenh the wave is already steep, then race down the slope and get far in front of the wave. In addition, I wanted to be as agile (tight curves) as with my kite-foil My design conditions therefore have been: keep the width at 70cm only (today typical SUP foils use 90cm or even larger!) get to fly at ~12km/h to catch the wave early before it gest to steep limit the max velocity via slef-limitation all in all, using a low aspect ratio (large chord relative to given spanwidth) and generating massive induced drag did the job and I'm quite pleased with the result.","title":"Kite &amp; SUP foils"},{"location":"blenderAirfoils/#the-basic-scripts","text":"I provide my scripts at github . The folder scripts contains wingLib.py, the library holding the basic worker routines and 2D airfoil data Folder Name Comment scripts wingLib.py basic worker routines to e.g. get from 2D points to 3D surfaces scripts afData_xy.py 2D airfoil data for profile xy planes/basicWing basicWing.blend the blender file for the basic wing example planes/basicWing ellipticPlaneWing.py the python script used in the basicWing.blend file to generate a planar wing with elliptic chord I currently include the h105 profile, which I (and many others) use for hydrofoils. This will be extended bit by bit according to my needs. Feel free to add your own profile data and send me a pull request. If you are looking for a specific dataset, check out UIUC Airfoil Database .","title":"The basic scripts"},{"location":"blenderAirfoils/#getting-started","text":"What we'll be doing: Take a set of points for a 2d profile (in this case the h105) Determine the position of the leading edge according to a parametrized curve (to achieve the seewp back of the wing tip region) Determine the chordlength along the span according to an elliptic curve Scale and place the 2D points and fit a curve through them (we then have a set of 2D profile curves placed in 3d as wing sections) Fit a surface through all the curves This gives us the 3D wing which could then be used for generating CAM paths using blenderCam. Open blender's scripting workspace Once you have blender up and running, clone the blenderCadCamTools . Start blender and open the basicWing.blend file. The reult should look like: If not, check to be on the scripting workspace - you can select the different workspace in the top menu to the right of the standard menue (File, ...). You will most probaly end-up switching between Modeling and Scripting . In the Scripting workspace, the script ellipticPlaneWing.py from the repo (stored right next to the blend file) should be open. If not, click the symbol which looks like a folder (second from right), browse to where you cloned the repo to and open planes/basicWing/ellipticPlaneWing.py","title":"Getting started"},{"location":"blenderAirfoils/#scripting-tools","text":"On the left side, you have the usual modeling wintow (top) python console (middle) where you can enter python commands python commands blender uses when you model (using the mouse and user interface). This is quite helful, as you can copy paste the commands over to your scripts Now click in the modeling window (top left) and hit n to pu-up the item transform dialogue which shows the location properties of the selected object (the wing). In the field for Location Y enter 0 and hit enter. The script output window (left bottom shows the python api used to set the Y location). Select via left-click (blue), right-click>copy and paste in the python console (left middle). Change '= 0' to e.g. = 0.042 and hit enter. The wing now moved to that position: This is what we use at the end of the script (line 99) to place the wing at the origin (previous figure on the right). Take home : what you can model can be scripted. Just open the scripting workspace and have a look at the api command output.","title":"Scripting tools"},{"location":"blenderAirfoils/#the-ellipticplanewingpy-script","text":"The first few lines import necessary libraries, then extend the path to include the blenderCadCam scripts directory. Line 10 uses a relative path (relative to the current blend file). If you cloned the repo, the scripts directory is 2 dirs up from basicWing.blend. Line 28 & 29 then imports / reloads the winLib (the reload is necessary in case the file changed during the blender session). Line 31/32 imports the h105 2d profile. Configure the if clause line 43 to 1 , 50 and 94 to 0 Hit run script (upper right of the script window). Noe the wing should have been disappeared. The deleteAll() helper routine in fact deletes all except the camera and lamp. Configure the if clause line 43 AND 50 to 1 , 94 to 0 . Run the script. You should now have a set of 2D profiles, named 2dsection_x . This is the result of executing steps 1.) to 4.) from some Configure the if clause line 43, 50 AND 94 to 1 . Run the script. This should give you the result of step 5: a surface fitted through the 2d curves. Read through the scripts, it should be pretty obvious. An important hint: the sufaces need to be closed, otherwize you will get weird errors later on (mainly when using boolean intersections for designing moulds etc.). This is done in two places: Each of the 2D curves are closed (in placeSectionsMinLimited calling curveBezierFromPoints(hCoord,name,True) True=closed curve) In bridgeListOfEdgeLoopsCloseOuterWithFace (as the name states: outer edge loop is closed with face)) Getting there took me quite some time fiddling around. It's like always: once you have it, it looks straight forward. You can now imagine how to generate bend-up wing tips etc. Either use the usual modeling tools of blender to do it once. Alternatively, define a function and adapt z location and y rotation of the individual sections before fitting the surface. Moulds can now be designed by subtracting the wing from cubes etc. Play a bit with the modeling interface, have a look at the api command output and start designing your own scripts.","title":"The ellipticPlaneWing.py script"},{"location":"blenderAirfoils/#adding-a-new-2d-profile","text":"Update: The following works as described. Hwoever,in the meantime I added the possibility to directly import dat files wingLib.foilImport() , resampling wingLib.foildDataReduceToNpoints() and re-sampling for morphing of profiles wingLib.interpolateBezier2on1() . See e.g. kissSlopeWing2.py discussed below . The follwing sequence can be used to add a new 2D profile, e.g. from the airfoil database . We will be doing this for the modified MH30. a) Prepare the py file Add a new airfoild data file in the scrpts directory, e.g. afData_mh30ModPK.py b) Get data in selig format Get the data in selig format (data starts at the trailing edge, goes the over the upper half to the leading edge and back again on the lower half). The airfoiltools site provides the selig format dat file. c) Store the data as python 3D array In the afData_mh30ModPK.py, in the function coords, add the profile data for quality super , as vector, with x all 0.0 def coords(quality,scale,shiftV): if(quality=='super'): coords=scale*np.array([ [0.0,-1.000019, 0.000581], ... [0.0, -0.875281,-0.0048557]])+shiftV d) Open a blend file and helper script Take a look at planes/kissSlope/howtoAddMH30.py for the python code related to the follwoing steps. You can e.g. open planes/kissSlope/kissSlopwWing.blend and enter the scripting workspace. I included the howtoAddMH30.py there. e) Generate dataseta with reduced number of points In howtoAddMH30.py , after the default header, activate the block reduce quality . Line 49 provides the super coordinates (unscaled and unshifted) and plugs it into a routine (line 50), which reduces the number of points while keeping the error below a certain value. Try e.g. 0.0002 to reduce the 200 datapoints of the MH30 super set to ~60. Keep the last parameter to False , such that you can see the curves testcurve and Simple_testcurve after running the script. Run the sript. Inspect the curve Simple_testcurve - this is the one with reduced number of points against testcurve . The following image shows only super-small differences (where the orange sections appear). Don't be irritated by the fact that the simplified curve is not yet closed at the trailing edge: Inspect blenders stdout for the reduced dataset in 3d array style and info about the number of points and leading edge index: Update afData_mh30ModPK.py 56 Points is good for full quality -> copy over the dataset into afData_mh30ModPK.py elif(quality=='full'): coords=scale*np.array([ ... and update the leading edge idx definition for this quality: def leadingEdgeIdx(quality): ... elif(quality=='full'): idx=33 ... Check the result Activate the block Check result . L55 fetches the data for the generated quality ( full in our current example) and l.56 fits a Beziercurve as we will do when generating 3D wings. The two boolean True parameters refer to: close the curve, and generate a sharp edge where the curve is closed (the trailing edge). Run the srcipt & inspect the resulting curve estcurveFin . If it looks good, continue wit medium and low quality (I used 0.0004 and 0.0008, respectively).","title":"Adding a new 2D profile"},{"location":"blenderAirfoils/#more-complex-wing-design","text":"We'll be using the following files: Folder Name Comment scripts wingLib.py basic worker routines to e.g. get from 2D points to 3D surfaces planes/kissSlope kissSlopeWing.blend the blender file planes/kissSlope kissSlopeWing2.py the python script used to generate a wing with configurable deviation from elliptic chord, multiple profiles and twist angle kissSlope2.py The header and geometric definition is as usual (L 1-60). We now have the possibility to import profile dat files e.g. applied in l. 66 providing the coordinate matrix and leading edge index. wingLib.foilDataReducetoNpoints() in l.81 allows to downsample the profile data (typically, for CAM model we don't ned as much points as e.g. for aerodynamic analysis). The downsampling reduces points such that the resulting qulaity of the curve is best conserved. wingLib.interpolateBezier2on1() in l.91 interpolates the second curve at the (angular) support points of the first profile. This is required for profile morphing (fading from one profile to another in spanwise direction), as this requires the same number of support points in similar angular distribution. In this example, we use the AG25 as root profile, then fade over to AG25 and AG14 in the outer region. L.96ff illustrates how to plot the profiles for an inspecton (you should to this to ensure that downsampleing etc. worked out well). L.111 compiles a dict for easy access of the prepared profile data L.123 - 128 defines the base sections: AG25 from span 0-5%, AG26 at 40% span, AG14 from 95% span. tA is the local twist angle. In ths subsections between two basic sections, the twist angle is linear interpolated betwenn the inner and outer basic section settings. \"tMorph\":True activates profile morphing for the subsections. Options (currenly) are lS and lCh . lS linearly morphes the profile according to the relative span position of the subsection between the basic sections (e.g. a subsection right between two base sections would be 50% left and 50% right profile). lCh morphes the profile linear according to the local chordlength compared to the chordlength of the enclosing basic profiles (which approx. relates to the local Reynoldsnumber). L.137 - 141 allows to configure a spanwise deviation from the pure elliptic chord distribution as added chordlength defined at arbitrary many span positions (linear interpolated in between). In the example, the span positions match the base section definitions, this however is not necessary! The rest is as usual and result in the 3D mesh of the wing:","title":"More complex wing design"},{"location":"blenderAirfoils/#out-hinge-line-design-projected-area","text":"We'll be using the following files: Folder Name Comment scripts wingLib.py basic worker routines planes/kissSlope kissSlopeWing.blend the blender file planes/kissSlope hingeLine.py the python script used to generate a sketch of the out- & hinge line hingeLine.py This is a simple script generating a beezier curve for the wing outline and a line for the hinge line like the one illustrated below: After the obligatory header and basic geometry definition, l.80ff defines the hinge line, which should be self-explanatory. The following lines then define the section-wise ch extension as dicussed above and plot the curves. The projected area can now easily be determined via: selecting the outline's curve in object mode > object > convert to mesh edit mode > select all points (hit a) > face > fill object mode > hit n to open the extended dialogue select the 4th elemnt in the vertical menue (item - tool - view - 3d print) Should the 3d print menue not show up, check to have preferences > add ons > 3d toolbox checked 3d print > hit the area button and find the area in the result field","title":"Out &amp; hinge line design, projected area"},{"location":"blenderInst/","text":"Installation Blender I currently use blender 's long term support version 2.83.9 (on linux) spcifically the tgz download, unpack and therein start blender. This allows me to use different versions in parallel (just in case). Add-ons For the curve simplification check to have edit>preferences>add-ons> Add curve: simplfy curves+ activated Python modules Blender comes with a bundled python in whereYouUnpacked/blender-2.91.0-linux64/2.91/python/bin First check to have an up to date pip3 in the bin dir: cd whereYouUnpacked/blender-2.91.0-linux64/2.91/python/bin ./python3.7m -m ensurepip ./python3.7m -m pip install -U pip Now you can install python modules ./pip3 install matplotlib For the foil analysis stuff, we need to be able to read / write xml files and tehrefore need ./pip3 install beautifulsoup4 BlenderCam In order to be able to use blendercam follow the documentation . I might later on add some notes here, but for now concentrate on the scripting part for wing design.","title":"Installation"},{"location":"blenderInst/#installation","text":"","title":"Installation"},{"location":"blenderInst/#blender","text":"I currently use blender 's long term support version 2.83.9 (on linux) spcifically the tgz download, unpack and therein start blender. This allows me to use different versions in parallel (just in case). Add-ons For the curve simplification check to have edit>preferences>add-ons> Add curve: simplfy curves+ activated Python modules Blender comes with a bundled python in whereYouUnpacked/blender-2.91.0-linux64/2.91/python/bin First check to have an up to date pip3 in the bin dir: cd whereYouUnpacked/blender-2.91.0-linux64/2.91/python/bin ./python3.7m -m ensurepip ./python3.7m -m pip install -U pip Now you can install python modules ./pip3 install matplotlib For the foil analysis stuff, we need to be able to read / write xml files and tehrefore need ./pip3 install beautifulsoup4","title":"Blender"},{"location":"blenderInst/#blendercam","text":"In order to be able to use blendercam follow the documentation . I might later on add some notes here, but for now concentrate on the scripting part for wing design.","title":"BlenderCam"},{"location":"blenderKissSlope/","text":"What is this This are some early thoughts and design for a simple to build (easy to replace) sailplane for slope soaring. With simple to build I mean simple when you have access to a cnc milling machine for milling foam. Wing outline The outline should be based on the elliptic planar wing basis. Having access to cnc milling, the straight outlines of the Swift or Kobutz are not required. We can make use of more organic-like and more efficient (regarding induced drag) shapes like the stingray. You have some spare time? Read Epplers great paper on induced drag and winglets . How do we achieve this? First, we import an image of the said geometry in blender. I used the outline provided at Rc-Network and, as an alternative with a more elliptic shape, also the modster flash, which is also sold as lightning V2. Import the image: add > Image > as background and place & scale it. In the scripting workspace, kissSlopeWing1.py should be open. In there, I have the configuration for a more modster-like layout and one with less backwards sweep similar to the stingray. I personally prefer the upper one (for aesthetic reasons). Update: During aerodynamic analysis I opted for a higher aspect ration (1:9.4) and an over-elliptic chordlength towards the outer wing as follows: In a nutshell: to have the wing root to stall first, we can use a wash-out or over-elliptic chordlength, with over-ellitic chordlenght is more beneficial at higher velocity (see detailed discussion below). Wing loading and Re Surface area For designing the 2d profiles along the wing span (strak, loft), we need to determine the wing loading, and the Reynolds number. First, we get the (projected) surface in blender : Edit>preference>add-ons>Mesh: 3d print toolbox - check to have the add-on activated Update: A simpler alternative to the following is to first sketch the outline as desribed here . We could now select the wing, hit N to pop up the info display (to the right). and select the 4th option (in the right-most menue - tilted by 90\u00b0) called 3D Print , the hit Area . This gives us the surface area of the wing: 5191.8cm\u00b2 But wait! this is the total surface, not the 2D projected which we need for equation basics (1) . To estimat the 2D projected surface: add a cube ob 2m x 1m x 0.0001m and place it at 0/0/0 (it intersects the wing through trailing and leading edge) copy the wing select the copied wing (myWing1.001 in my case) in object mode select the wrench select add modifier: boolean set to insersect with the plane important: apply the modifier; this since 2.8x this is somewhat hidden: hit the triangel right to the camera and select apply (otherwize you will not see the correct mesh in the next step) hide myWing1 and Cube enter edit mode for myWing1.001 You should see a quite flat mesh (not curved like in the original wing). The 3d Print aera now gives us 5128.7cm\u00b2. The projected area is \\(\\frac{1}{2}\\cdot 5128.7cm\u00b2=\\textbf{0.2564m\u00b2}\\) Update: The updated outline has a projected area of \\(\\textbf{0.2342m\u00b2}\\) Note: this approach will not work when intersecting with a plane (don't ask me why). Therefore, I use a thin cube. Weight, minimal velocity an Re I currently estimate the total weight to 900g and 1300g including some extra ballast (actually 800g, but we need to estimate with a bit of safety margin). For the suface area determined above, this gives a wing loading of 35g/dm\u00b2 and 51g/dm\u00b2, respectively. We can now determine \\(v\\) from basics (2) , if we make use of the hypothesis \\(c_{L}\\approx 1.0\\) . We will cross-check this later! \\(v_{min900g}=\\sqrt{\\frac{2\\cdot 0.9kg\\cdot 9.81 m/s\u00b2}{1.1673kg/m\u00b3\\cdot 1.0 \\cdot 0.2564m\u00b2}}=7.68 m/s\\) \\(v_{min1300g}=\\sqrt{\\frac{2\\cdot 1.3kg\\cdot 9.81 m/s\u00b2}{1.1673kg/m\u00b3\\cdot 1.0 \\cdot 0.2564m\u00b2}}=9.23 m/s\\) Inserting in basics (3) allows us to plot the Reynolds number over span: for 1300g and 900g Using xflr5 for analysis T1: 6:45 allows us to check our hypothesis \\(c_{L}\\approx 1.0\\) from above: Click the image to enlarge. See the Cl/ALPHA plot (upper mid): for \\(Re>40.000\\) corrsponding to \\(\\sim 93\\%\\) of the wing span, \\(c_{l}>1.0\\) (note that we use a small index here, as it is a local variable - for the given location). The inner region (with larger chord) even provides us a safety margin, compensating the decreasing lift at the outer sections of the wing. And this is still the plain vanilla MH30_pk profile! Resume: For a plane lighther than 900g, faster than 7.68m/s (lighter than 1300g, faster than 9.23m/s), our hypothesis \\(c_{L}\\not\\lt 1.0\\) therefore holds with safety margin, which means we can maintain height. But: Regarding stability we would require that flow seperation and hence drop of \\(c_{l}\\) should begin at the inner part of the wing (close to the fuselage) and not from the wingtips. Why? In the first case, the result will be a plane loosing height (sagging) but still being controllable. In the second case, loosing lift force suddenly at the outer wing region will result in the plane rolling to that side. Steering against the roll (aileron down, corresponds to an increased angle of attack) makes the situation even worse, because an even larger region is pushed beyond the maximal possible angle of attack \\(\\alpha_{attackMax}\\) , the angle where breakdown of lift occurs. Having a look at the \\(c_{l}\\) /APLHA plot shows that (for a given profile) the maximum lift gets lower at an ever smaller angle of attack with decresing Reynolds number. Therefore, without taking means against, this leads to break down of lift starting at the wing tips (because we have smalle \\(Re\\) there). Means are Geometrically decreasig the angle of attack towards wing tips ( twist / washout ), which is inefficient (as the drag increases). A better alternative are aerodynamic means: designing and using a profile with adequate \\(c_{l} / c_{d}\\) for the outer wing region, Re at normal & speed flight The considerations above are important for slow flight & high lift situations (thermal climbing, landing, tack). However, at normal flight in good conditions, the Re will be much larger. In these situations, it is important to have low \\(c_D\\) . To get an impression, I plot Re(span) for slow, medium and high speed normal flight: Profiles: preselection Basic considerations There are a plethora of different profiles out there for different purposes. You can find detailed discussions and spend hours reading. I won't go into depth here (others have done this; for german readers see e.g. the great work of Hartmut Siegmann ; if you know a comparable site in english, please let me know), but will only document some steps and considerations I have taken . If you identify mistakes, please let me know! First step: collect design ResqrtCl's (actually \\(Re\\sqrt{C_l}\\) ). Why? See ResqrtCl derivation . At a given wing section (fixed chordlength \\(ch\\) ), at horicontal flight, this is a constant number. In other words: if we know the weight of the plane and require horicontal flight , this determines the flight conditions ( \\(\\alpha\\) , \\(Cl\\) , \\(Re\\) ). This allows us to study e.g. \\(C_l/C_d\\) over the flight states (and e.g. plot it over the resulting \\(\\alpha\\) ). As discussed above, the hypothesis of \\(C_l\\approx1.0\\) at \\(v_{min}\\) holds. Therefore \\(Re\\sqrt{C_l}\\approx Re\\) . We can therefore select some spanwise positions an note \\(Re\\approx Re\\sqrt{Cl}\\approx const\\) . Typically we choose the following positions: Re @ 0-5% span Re @ 50% span Re @ 95% span 900g 103k 89k 33k 1300g 124k 107k 39k \\(Re\\approx Re\\sqrt{Cl}\\) at relative span position for the two considered weights Robustness or high performance? In a nutshell, a profile can not be robust (with respect to how exact can we build, how smooth will the surface be, etc.) and deliver high performance (e.g. max \\(C_L\\) low \\(C_D\\) ) over a wide range of flight condition at the same time. If we e.g. go for minimal \\(C_D\\) at a high speed condition, we will pay for it in other conditions etc. For the kissSlope, I decided for robustness (in multiple dimensions). I collected the following list of considerations, conclusion and (where available) link to a related discusion (might be in german, mainly for my own reference): Consideration Conclusion Details 1. Profiles with long laminar flow get prob. quite bad if we mess it (e.g. geometrically or flight conditions e.g. lower Re at weak conditions) Try to use a bubble ramp like profile (e.g. the AG24, 25, 26 ) We will discuss and illustrate it below. See e.g. the discussion of the MH30 . 2. \\(C_D\\) at low \\(C_L\\) (normal & speed flight) is dominated by parasitic drag from hull, elevator etc. We will rather go for a reasonably low \\(C_D\\) over a larger range of \\(C_L\\) instead of optimizing for a super low \\(C_D\\) in XFLR5 Stingray thread , Philip Kolb's post 3. We can not have a profile which is both, optimal for speed (non-bubble ramp) and weak conditions Probably build 2 sets of wings, or, as I have planes for weak conditions build the heavier one 4. At high lift, the induced drag dominates. For the kissSlope which is not intended for weak conditions, we will be flying at \\(C_l<0.6\\) , and usual velocities of 15-20 m/s. For landing, higher \\(C_d\\) at high \\(C_L\\) is advantageous. See my dicussion of the wing outline above, and Hans Rupp's comments 5. Minimal sink rate should leave some saftey margin towards stall Check to have \\(\\alpha_{max}>\\alpha_{minSink}+safetyMargin\\) Hans Rupp's comments 6. For stability we need the wing root to stall first The profiles towards (spanwise) wingtip, where we have lower Re should have \\({\\alpha}_{max}\\) larger than at the root. 7. Neutral lift angle of attack should match along span Check \\(\\alpha_{C_l=0}\\) across span MHSD discussion XFLR5 Results - AGxx or else? Discussion to 1. As far as I understood, bubble ramp profiles (Mark Drela's AGxx, SD7003, ...) generate an early laminar -> turbulent transition in the boundary layer. This is not as efficient as profiles which mainatain a longer laminar flow. However, once flow separation occurs, the form of separation my highly influence the resulting drag (see Martin Hepperle's explanation) . See the great explanation by learnfluidmechanics' video , from which I took the following screenshot (2:30) : Therefore, the long laminar profiles might me more efficient at higher Re, at are at rsik to generate larger flow separation bubbles, which then completely messes-up the performance at lower Re. With this in mind let's see how the AGxx profiles perform in comparison to the other profiles usually referenced (for gliders at higher Re). For the following (type2) analysis I used the max \\(Re\\sqrt{C_l}=124k\\) from the table above (at the wing root for the heavier version), as I expect the effects getting even stronger for lower ResqrtCl. Solving basics (1) for \\(C_L\\) and assume expected normal velocities of 15-25 m/s, we end-up with \\(C_{L,900g,15-20m/s}\\approx 0.3 - 0.1\\) \\(C_{L,1300g,15-20m/s}\\approx 0.4 - 0.15\\) Zoomed in \\(C_L / C_D\\) shows: Might be that at high velocities, the non bubble-ramp profiles are a bit more efficient. However, I'd say for this glider we'd stick with AGxx.","title":"KissSlope project"},{"location":"blenderKissSlope/#what-is-this","text":"This are some early thoughts and design for a simple to build (easy to replace) sailplane for slope soaring. With simple to build I mean simple when you have access to a cnc milling machine for milling foam.","title":"What is this"},{"location":"blenderKissSlope/#wing-outline","text":"The outline should be based on the elliptic planar wing basis. Having access to cnc milling, the straight outlines of the Swift or Kobutz are not required. We can make use of more organic-like and more efficient (regarding induced drag) shapes like the stingray. You have some spare time? Read Epplers great paper on induced drag and winglets . How do we achieve this? First, we import an image of the said geometry in blender. I used the outline provided at Rc-Network and, as an alternative with a more elliptic shape, also the modster flash, which is also sold as lightning V2. Import the image: add > Image > as background and place & scale it. In the scripting workspace, kissSlopeWing1.py should be open. In there, I have the configuration for a more modster-like layout and one with less backwards sweep similar to the stingray. I personally prefer the upper one (for aesthetic reasons). Update: During aerodynamic analysis I opted for a higher aspect ration (1:9.4) and an over-elliptic chordlength towards the outer wing as follows: In a nutshell: to have the wing root to stall first, we can use a wash-out or over-elliptic chordlength, with over-ellitic chordlenght is more beneficial at higher velocity (see detailed discussion below).","title":"Wing outline"},{"location":"blenderKissSlope/#wing-loading-and-re","text":"","title":"Wing loading and Re"},{"location":"blenderKissSlope/#surface-area","text":"For designing the 2d profiles along the wing span (strak, loft), we need to determine the wing loading, and the Reynolds number. First, we get the (projected) surface in blender : Edit>preference>add-ons>Mesh: 3d print toolbox - check to have the add-on activated Update: A simpler alternative to the following is to first sketch the outline as desribed here . We could now select the wing, hit N to pop up the info display (to the right). and select the 4th option (in the right-most menue - tilted by 90\u00b0) called 3D Print , the hit Area . This gives us the surface area of the wing: 5191.8cm\u00b2 But wait! this is the total surface, not the 2D projected which we need for equation basics (1) . To estimat the 2D projected surface: add a cube ob 2m x 1m x 0.0001m and place it at 0/0/0 (it intersects the wing through trailing and leading edge) copy the wing select the copied wing (myWing1.001 in my case) in object mode select the wrench select add modifier: boolean set to insersect with the plane important: apply the modifier; this since 2.8x this is somewhat hidden: hit the triangel right to the camera and select apply (otherwize you will not see the correct mesh in the next step) hide myWing1 and Cube enter edit mode for myWing1.001 You should see a quite flat mesh (not curved like in the original wing). The 3d Print aera now gives us 5128.7cm\u00b2. The projected area is \\(\\frac{1}{2}\\cdot 5128.7cm\u00b2=\\textbf{0.2564m\u00b2}\\) Update: The updated outline has a projected area of \\(\\textbf{0.2342m\u00b2}\\) Note: this approach will not work when intersecting with a plane (don't ask me why). Therefore, I use a thin cube.","title":"Surface area"},{"location":"blenderKissSlope/#weight-minimal-velocity-an-re","text":"I currently estimate the total weight to 900g and 1300g including some extra ballast (actually 800g, but we need to estimate with a bit of safety margin). For the suface area determined above, this gives a wing loading of 35g/dm\u00b2 and 51g/dm\u00b2, respectively. We can now determine \\(v\\) from basics (2) , if we make use of the hypothesis \\(c_{L}\\approx 1.0\\) . We will cross-check this later! \\(v_{min900g}=\\sqrt{\\frac{2\\cdot 0.9kg\\cdot 9.81 m/s\u00b2}{1.1673kg/m\u00b3\\cdot 1.0 \\cdot 0.2564m\u00b2}}=7.68 m/s\\) \\(v_{min1300g}=\\sqrt{\\frac{2\\cdot 1.3kg\\cdot 9.81 m/s\u00b2}{1.1673kg/m\u00b3\\cdot 1.0 \\cdot 0.2564m\u00b2}}=9.23 m/s\\) Inserting in basics (3) allows us to plot the Reynolds number over span: for 1300g and 900g Using xflr5 for analysis T1: 6:45 allows us to check our hypothesis \\(c_{L}\\approx 1.0\\) from above: Click the image to enlarge. See the Cl/ALPHA plot (upper mid): for \\(Re>40.000\\) corrsponding to \\(\\sim 93\\%\\) of the wing span, \\(c_{l}>1.0\\) (note that we use a small index here, as it is a local variable - for the given location). The inner region (with larger chord) even provides us a safety margin, compensating the decreasing lift at the outer sections of the wing. And this is still the plain vanilla MH30_pk profile! Resume: For a plane lighther than 900g, faster than 7.68m/s (lighter than 1300g, faster than 9.23m/s), our hypothesis \\(c_{L}\\not\\lt 1.0\\) therefore holds with safety margin, which means we can maintain height. But: Regarding stability we would require that flow seperation and hence drop of \\(c_{l}\\) should begin at the inner part of the wing (close to the fuselage) and not from the wingtips. Why? In the first case, the result will be a plane loosing height (sagging) but still being controllable. In the second case, loosing lift force suddenly at the outer wing region will result in the plane rolling to that side. Steering against the roll (aileron down, corresponds to an increased angle of attack) makes the situation even worse, because an even larger region is pushed beyond the maximal possible angle of attack \\(\\alpha_{attackMax}\\) , the angle where breakdown of lift occurs. Having a look at the \\(c_{l}\\) /APLHA plot shows that (for a given profile) the maximum lift gets lower at an ever smaller angle of attack with decresing Reynolds number. Therefore, without taking means against, this leads to break down of lift starting at the wing tips (because we have smalle \\(Re\\) there). Means are Geometrically decreasig the angle of attack towards wing tips ( twist / washout ), which is inefficient (as the drag increases). A better alternative are aerodynamic means: designing and using a profile with adequate \\(c_{l} / c_{d}\\) for the outer wing region,","title":"Weight, minimal velocity an Re"},{"location":"blenderKissSlope/#re-at-normal-speed-flight","text":"The considerations above are important for slow flight & high lift situations (thermal climbing, landing, tack). However, at normal flight in good conditions, the Re will be much larger. In these situations, it is important to have low \\(c_D\\) . To get an impression, I plot Re(span) for slow, medium and high speed normal flight:","title":"Re at normal &amp; speed flight"},{"location":"blenderKissSlope/#profiles-preselection","text":"","title":"Profiles: preselection"},{"location":"blenderKissSlope/#basic-considerations","text":"There are a plethora of different profiles out there for different purposes. You can find detailed discussions and spend hours reading. I won't go into depth here (others have done this; for german readers see e.g. the great work of Hartmut Siegmann ; if you know a comparable site in english, please let me know), but will only document some steps and considerations I have taken . If you identify mistakes, please let me know! First step: collect design ResqrtCl's (actually \\(Re\\sqrt{C_l}\\) ). Why? See ResqrtCl derivation . At a given wing section (fixed chordlength \\(ch\\) ), at horicontal flight, this is a constant number. In other words: if we know the weight of the plane and require horicontal flight , this determines the flight conditions ( \\(\\alpha\\) , \\(Cl\\) , \\(Re\\) ). This allows us to study e.g. \\(C_l/C_d\\) over the flight states (and e.g. plot it over the resulting \\(\\alpha\\) ). As discussed above, the hypothesis of \\(C_l\\approx1.0\\) at \\(v_{min}\\) holds. Therefore \\(Re\\sqrt{C_l}\\approx Re\\) . We can therefore select some spanwise positions an note \\(Re\\approx Re\\sqrt{Cl}\\approx const\\) . Typically we choose the following positions: Re @ 0-5% span Re @ 50% span Re @ 95% span 900g 103k 89k 33k 1300g 124k 107k 39k \\(Re\\approx Re\\sqrt{Cl}\\) at relative span position for the two considered weights Robustness or high performance? In a nutshell, a profile can not be robust (with respect to how exact can we build, how smooth will the surface be, etc.) and deliver high performance (e.g. max \\(C_L\\) low \\(C_D\\) ) over a wide range of flight condition at the same time. If we e.g. go for minimal \\(C_D\\) at a high speed condition, we will pay for it in other conditions etc. For the kissSlope, I decided for robustness (in multiple dimensions). I collected the following list of considerations, conclusion and (where available) link to a related discusion (might be in german, mainly for my own reference): Consideration Conclusion Details 1. Profiles with long laminar flow get prob. quite bad if we mess it (e.g. geometrically or flight conditions e.g. lower Re at weak conditions) Try to use a bubble ramp like profile (e.g. the AG24, 25, 26 ) We will discuss and illustrate it below. See e.g. the discussion of the MH30 . 2. \\(C_D\\) at low \\(C_L\\) (normal & speed flight) is dominated by parasitic drag from hull, elevator etc. We will rather go for a reasonably low \\(C_D\\) over a larger range of \\(C_L\\) instead of optimizing for a super low \\(C_D\\) in XFLR5 Stingray thread , Philip Kolb's post 3. We can not have a profile which is both, optimal for speed (non-bubble ramp) and weak conditions Probably build 2 sets of wings, or, as I have planes for weak conditions build the heavier one 4. At high lift, the induced drag dominates. For the kissSlope which is not intended for weak conditions, we will be flying at \\(C_l<0.6\\) , and usual velocities of 15-20 m/s. For landing, higher \\(C_d\\) at high \\(C_L\\) is advantageous. See my dicussion of the wing outline above, and Hans Rupp's comments 5. Minimal sink rate should leave some saftey margin towards stall Check to have \\(\\alpha_{max}>\\alpha_{minSink}+safetyMargin\\) Hans Rupp's comments 6. For stability we need the wing root to stall first The profiles towards (spanwise) wingtip, where we have lower Re should have \\({\\alpha}_{max}\\) larger than at the root. 7. Neutral lift angle of attack should match along span Check \\(\\alpha_{C_l=0}\\) across span MHSD discussion","title":"Basic considerations"},{"location":"blenderKissSlope/#xflr5-results-agxx-or-else","text":"Discussion to 1. As far as I understood, bubble ramp profiles (Mark Drela's AGxx, SD7003, ...) generate an early laminar -> turbulent transition in the boundary layer. This is not as efficient as profiles which mainatain a longer laminar flow. However, once flow separation occurs, the form of separation my highly influence the resulting drag (see Martin Hepperle's explanation) . See the great explanation by learnfluidmechanics' video , from which I took the following screenshot (2:30) : Therefore, the long laminar profiles might me more efficient at higher Re, at are at rsik to generate larger flow separation bubbles, which then completely messes-up the performance at lower Re. With this in mind let's see how the AGxx profiles perform in comparison to the other profiles usually referenced (for gliders at higher Re). For the following (type2) analysis I used the max \\(Re\\sqrt{C_l}=124k\\) from the table above (at the wing root for the heavier version), as I expect the effects getting even stronger for lower ResqrtCl. Solving basics (1) for \\(C_L\\) and assume expected normal velocities of 15-25 m/s, we end-up with \\(C_{L,900g,15-20m/s}\\approx 0.3 - 0.1\\) \\(C_{L,1300g,15-20m/s}\\approx 0.4 - 0.15\\) Zoomed in \\(C_L / C_D\\) shows: Might be that at high velocities, the non bubble-ramp profiles are a bit more efficient. However, I'd say for this glider we'd stick with AGxx.","title":"XFLR5 Results - AGxx or else?"},{"location":"blenderMot/","text":"Motivation for using Blender After my initial tests with FreeCad, I opted for blender and the great blendercam for design and gCode generation for complex parts (like airfoils). The main reason is that I usually build 3d sphapes like surfboards, airfoils and wings for hydrofoils, which I construct script based. Blender is great for this. I might add some more details about my approach in this section. Some examples: The following 3 pictures show 1/4 of a SUP board foam core with heavily milled-away foam in the inner. The holes go 'down' to 10mm distnace from the surface. The follwoing picture shows 1/2 of an airfoil including the calculated milling path for coarse milling.","title":"Motivation"},{"location":"blenderMot/#motivation-for-using-blender","text":"After my initial tests with FreeCad, I opted for blender and the great blendercam for design and gCode generation for complex parts (like airfoils). The main reason is that I usually build 3d sphapes like surfboards, airfoils and wings for hydrofoils, which I construct script based. Blender is great for this. I might add some more details about my approach in this section. Some examples: The following 3 pictures show 1/4 of a SUP board foam core with heavily milled-away foam in the inner. The holes go 'down' to 10mm distnace from the surface. The follwoing picture shows 1/2 of an airfoil including the calculated milling path for coarse milling.","title":"Motivation for using Blender"},{"location":"ext_1/","text":"Sensible settings & ramp in dressup We'll do the following: use a higher feed (as we are milling xps) use a step over of 25% of tool diameter adapt the step down 2.5mm to get the full depth at 2 passes (actually not necessary for xps add a path dressup which adds a ramp to the plunging into the material Finishing passes & holding tags We'll do the following: add a finishing pass to the pocket inner contour, based on the edges add a finishing pass to the island contour based on the face add a holding tag dressup to the island countour pass For the passes I use climb milling (setting ccw ). Why? See my milling precision experiments discussed here and here . Sliptonic has great Freecad videos. Regarding holding tag dressup . We did not cover how to set the starting point for the path. I f you need it, have a look at sliponics video Feel free to dicuss your questions in the related discussion thread","title":"Freecad - ramp in, finsish pass, holding tags"},{"location":"ext_1/#sensible-settings-ramp-in-dressup","text":"We'll do the following: use a higher feed (as we are milling xps) use a step over of 25% of tool diameter adapt the step down 2.5mm to get the full depth at 2 passes (actually not necessary for xps add a path dressup which adds a ramp to the plunging into the material","title":"Sensible settings &amp; ramp in dressup"},{"location":"ext_1/#finishing-passes-holding-tags","text":"We'll do the following: add a finishing pass to the pocket inner contour, based on the edges add a finishing pass to the island contour based on the face add a holding tag dressup to the island countour pass For the passes I use climb milling (setting ccw ). Why? See my milling precision experiments discussed here and here . Sliptonic has great Freecad videos. Regarding holding tag dressup . We did not cover how to set the starting point for the path. I f you need it, have a look at sliponics video Feel free to dicuss your questions in the related discussion thread","title":"Finishing passes &amp; holding tags"},{"location":"firmware_1/","text":"Controller & firmware options A, B, C are different options; choose the one you prefer \u2013 as always, at your own risk! A) Grbl on Ramps - default mpcnc (no dual end stops) (and possibly others *1 ) Controller & firmware *1) please report about any other boards in use including a link to documentation With the default mpcnc setup (non-dual end stop firmware & wiring) based on ramps, an approach is to use the rgbl ramps solution by @mschrock et.al. I followed the instructions there (downloaded the newest version from the 1.Download this repository link pointing to the github of carlos. Compiled in arduino IDE ( as usual - see the section flash firmware ) and flashed. I could not test it as I have the dual end-stop setup and don\u2019t want to screw up my machine. I have read of people using it successfully. Perhaps someone could confirm this, then we could mark this here as confirmed. Front-end For boards running gbrl bCnC is a great solution, as it runs on python and therefore should be available on many platforms. B) Grbl on Ramps \u2013 dual-end-stop, auto-squaring Controller & firmware @Pablo did great work documented here to get it up and running, based on grbl-Mega-5X . One or two end-stops per axis, NO or NC mode, all discussed in the linked thread! See also the detailed tutorial ZOOM on option B) . The \u2018main\u2019 post with the download link to the current version. Front-end bCnC C) General solution Marlin-mpcnc post in FreeCad Not yet (I need to test it): provide an path: output: mpcnc-marlin option in FreeCad. Looks doable to me. If you want to get this going, see and support this To be honest, I like this approach, as it would allow everybody to stick with the default firmware and his board. There are some inputs on known issues and how these could be solved. G0, G1, G17, g18/g19 & g2/g3 issue Jeffeb3's input Any hint about possible other problems or approaches how to get some confidence (e.g. which commands to crosscheck) highly appreciated. If someone whants to jump in - please contact me Controller & firmware Just the controller you have. Possibly two firmware parameters to adapt (ARC_SUPPORT and CNC_WORKSPACE_PLANES). Front-end Just what you are using currently. Feel free to dicuss your questions in the related discussion thread","title":"Controller board, firmware"},{"location":"firmware_1/#controller-firmware-options","text":"A, B, C are different options; choose the one you prefer \u2013 as always, at your own risk!","title":"Controller &amp; firmware options"},{"location":"firmware_1/#a-grbl-on-ramps-default-mpcnc-no-dual-end-stops","text":"(and possibly others *1 )","title":"A) Grbl on Ramps - default mpcnc (no dual end stops)"},{"location":"firmware_1/#controller-firmware","text":"*1) please report about any other boards in use including a link to documentation With the default mpcnc setup (non-dual end stop firmware & wiring) based on ramps, an approach is to use the rgbl ramps solution by @mschrock et.al. I followed the instructions there (downloaded the newest version from the 1.Download this repository link pointing to the github of carlos. Compiled in arduino IDE ( as usual - see the section flash firmware ) and flashed. I could not test it as I have the dual end-stop setup and don\u2019t want to screw up my machine. I have read of people using it successfully. Perhaps someone could confirm this, then we could mark this here as confirmed.","title":"Controller &amp; firmware"},{"location":"firmware_1/#front-end","text":"For boards running gbrl bCnC is a great solution, as it runs on python and therefore should be available on many platforms.","title":"Front-end"},{"location":"firmware_1/#b-grbl-on-ramps-dual-end-stop-auto-squaring","text":"","title":"B) Grbl on Ramps \u2013 dual-end-stop, auto-squaring"},{"location":"firmware_1/#controller-firmware_1","text":"@Pablo did great work documented here to get it up and running, based on grbl-Mega-5X . One or two end-stops per axis, NO or NC mode, all discussed in the linked thread! See also the detailed tutorial ZOOM on option B) . The \u2018main\u2019 post with the download link to the current version.","title":"Controller &amp; firmware"},{"location":"firmware_1/#front-end_1","text":"bCnC","title":"Front-end"},{"location":"firmware_1/#c-general-solution-marlin-mpcnc-post-in-freecad","text":"Not yet (I need to test it): provide an path: output: mpcnc-marlin option in FreeCad. Looks doable to me. If you want to get this going, see and support this To be honest, I like this approach, as it would allow everybody to stick with the default firmware and his board. There are some inputs on known issues and how these could be solved. G0, G1, G17, g18/g19 & g2/g3 issue Jeffeb3's input Any hint about possible other problems or approaches how to get some confidence (e.g. which commands to crosscheck) highly appreciated. If someone whants to jump in - please contact me","title":"C) General solution Marlin-mpcnc post in FreeCad"},{"location":"firmware_1/#controller-firmware_2","text":"Just the controller you have. Possibly two firmware parameters to adapt (ARC_SUPPORT and CNC_WORKSPACE_PLANES).","title":"Controller &amp; firmware"},{"location":"firmware_1/#front-end_2","text":"Just what you are using currently. Feel free to dicuss your questions in the related discussion thread","title":"Front-end"},{"location":"freecad_1/","text":"Foreword Note: I use the blender interface for freecad (as I\u2019m using blender regularly). Just right-click in the main window and select navigation-style> blender (shown in the 2nd video). Note: After my initial tests with FreeCad, I opted for blender and the great blendercam for design and gCode generation for complex parts (like airfoils). See my motivation . Functionality Shortcut 3D rotation middle mouse botton + move the mouse Move the view shift + middel mouse button + move the mouse Scale mouse wheel or ctrl + middle mouse button + move the mouse 0. Getting Freecad Freecad provides appImages / binaries for Win / Mac / Linux. Just download and execute it. We will base this tutorial on the current stable release 0.18 1. Getting started: prepare for body creation We will open part design and create a sketch (which is a 2D drawing, allowing for constraints etc.) which will then be the basis for the 3D body 2. Sketching a square, using constraints, extrude to body 3. Adapting the geometry How to use the underlying sketch (the constraints therein) to adapt the body geometry. This illustrates a basic design feature I like in freecad: all the steps build on oneanother (its like filters / adaptors applied in sequence). You can adapt almost all of them later on an the result will be adapted. 4. Making a pocket You can easily match a sketch on a face of a 3d body, do some 2d design and use it as the basis of 3D body modification. 5. Adding an island 6. Configure the path workbench, create the pocketing operation 7. Visualize and correct the finishing allowance In the last video we generated the pocketing operation; checking the visualization we recognize that we had used the wrong sign for the finish allowance and correct it here 8. Export gcode Open points check if we could have holding tabs generated: thanks to @edwardvmills: holding tabs are called \u2018tags\u2019 and are available as a \u2018Dressup\u2019 on an operation. tutorial tbd. we use 5mm in z. add a short video to show how to use a plunge angle and smaller milling depth per pass 3d milling Feel free to dicuss your questions in the related discussion thread","title":"Freecad part 1"},{"location":"freecad_1/#foreword","text":"Note: I use the blender interface for freecad (as I\u2019m using blender regularly). Just right-click in the main window and select navigation-style> blender (shown in the 2nd video). Note: After my initial tests with FreeCad, I opted for blender and the great blendercam for design and gCode generation for complex parts (like airfoils). See my motivation . Functionality Shortcut 3D rotation middle mouse botton + move the mouse Move the view shift + middel mouse button + move the mouse Scale mouse wheel or ctrl + middle mouse button + move the mouse","title":"Foreword"},{"location":"freecad_1/#0-getting-freecad","text":"Freecad provides appImages / binaries for Win / Mac / Linux. Just download and execute it. We will base this tutorial on the current stable release 0.18","title":"0. Getting Freecad"},{"location":"freecad_1/#1-getting-started-prepare-for-body-creation","text":"We will open part design and create a sketch (which is a 2D drawing, allowing for constraints etc.) which will then be the basis for the 3D body","title":"1. Getting started: prepare for body creation"},{"location":"freecad_1/#2-sketching-a-square-using-constraints-extrude-to-body","text":"","title":"2.  Sketching a square, using constraints, extrude to body"},{"location":"freecad_1/#3-adapting-the-geometry","text":"How to use the underlying sketch (the constraints therein) to adapt the body geometry. This illustrates a basic design feature I like in freecad: all the steps build on oneanother (its like filters / adaptors applied in sequence). You can adapt almost all of them later on an the result will be adapted.","title":"3. Adapting the geometry"},{"location":"freecad_1/#4-making-a-pocket","text":"You can easily match a sketch on a face of a 3d body, do some 2d design and use it as the basis of 3D body modification.","title":"4. Making a pocket"},{"location":"freecad_1/#5-adding-an-island","text":"","title":"5. Adding an island"},{"location":"freecad_1/#6-configure-the-path-workbench-create-the-pocketing-operation","text":"","title":"6. Configure the path workbench, create the pocketing operation"},{"location":"freecad_1/#7-visualize-and-correct-the-finishing-allowance","text":"In the last video we generated the pocketing operation; checking the visualization we recognize that we had used the wrong sign for the finish allowance and correct it here","title":"7. Visualize and correct the finishing allowance"},{"location":"freecad_1/#8-export-gcode","text":"","title":"8. Export gcode"},{"location":"freecad_1/#open-points","text":"check if we could have holding tabs generated: thanks to @edwardvmills: holding tabs are called \u2018tags\u2019 and are available as a \u2018Dressup\u2019 on an operation. tutorial tbd. we use 5mm in z. add a short video to show how to use a plunge angle and smaller milling depth per pass 3d milling Feel free to dicuss your questions in the related discussion thread","title":"Open points"},{"location":"freecad_2/","text":"Install opencamlib Note: After my initial tests with FreeCad, I opted for blender and the great blendercam for design and gCode generation for complex parts (like airfoils). See my motivation . Get it here and build it. Simple cmake build. On my linux system, after installation even after checking that everything is installen in /usr/local/lib and executing ldconfig /usr/local/lib for Freecad to find in () I got OpenCamLib is not working! when starting Freecad and the path workbench. The second option is to copy the compiled librarie(s) in the macro folder. Find out the macro path in freecad preferences. and copy Feel free to dicuss your questions in the related discussion thread","title":"Freecad - prepare for 3D"},{"location":"freecad_2/#install-opencamlib","text":"Note: After my initial tests with FreeCad, I opted for blender and the great blendercam for design and gCode generation for complex parts (like airfoils). See my motivation . Get it here and build it. Simple cmake build. On my linux system, after installation even after checking that everything is installen in /usr/local/lib and executing ldconfig /usr/local/lib for Freecad to find in () I got OpenCamLib is not working! when starting Freecad and the path workbench. The second option is to copy the compiled librarie(s) in the macro folder. Find out the macro path in freecad preferences. and copy Feel free to dicuss your questions in the related discussion thread","title":"Install opencamlib"},{"location":"mill_1/","text":"Import the gcode File>Open the gcode exported in tutorial 1 in bCNC In the control tab, you can select the desired view (e.g. x-y and y-z) as shown in the following pictures The red circle / triagle indicates the position of the machine relative to the workspace position (WPos). Note that, different from estlcam 2D default, the origin of the path is below the part (as can be seen in the y-z view). Have a look in the gcode to see that we work from positive coordinates down: - clearance plane at z=+25 - workpiece top z=+20 (freecad's start depth) - working down to z=+15 (freecad's final depth) Attentive observes will realize in the images and video, that I accidently used z=+25 (which is the clearence height) instead of z=+20mm, the actual start height for my milling operation. The follwoing description describes the correct setting. Have a look at the depth settings of the job in FreeCAD, especially Clearence height , Start Depth and Final Depth to crosscheck the correct settings. Position your machine: Move your machine and place it relative to the workpiece where you want to have your x/y zero. Hit xy=0 in the control window you should now have the red circle in x-y view right on the origin of the path: Position the milling cutter right on top of the workpiece. This is the Start Depth - in our case z=+20mm Use g92 z 20 to set the machine position accordingly (and not +25 as I did). Move up in Z, power on the spindle Hit Start in the control pane. The nice thing about grbl is that you can interrupt any command and the machine will (mostly) react instantly - even when e.g. making a long move. Just hit Pause or Stop . This is different from Marlin, where you only can pause or stop after the execution of the current command. Use the feed slider to slow down or speed up the milling procedure. I applied a speed-up as we used the MDF settings for the milling operation but are milling XPS. Possible pitfall - why did I use the wrong z position? Have a look at the y-z view (the first image). I wrongly interpreted the topmost plane of the path as start depth, which is wrong . The path is actually up to clearence plane (z=+25), over to the start position (in x-y) for plunging, fast down to to start depth . So be carefule in interpretation of what you see. Machine at work Open points Add some holding tags Ramp or hlical plunge Step down in smaller amounts Feel free to dicuss your questions in the related discussion thread","title":"Milling part 1"},{"location":"mill_1/#import-the-gcode","text":"File>Open the gcode exported in tutorial 1 in bCNC In the control tab, you can select the desired view (e.g. x-y and y-z) as shown in the following pictures The red circle / triagle indicates the position of the machine relative to the workspace position (WPos). Note that, different from estlcam 2D default, the origin of the path is below the part (as can be seen in the y-z view). Have a look in the gcode to see that we work from positive coordinates down: - clearance plane at z=+25 - workpiece top z=+20 (freecad's start depth) - working down to z=+15 (freecad's final depth) Attentive observes will realize in the images and video, that I accidently used z=+25 (which is the clearence height) instead of z=+20mm, the actual start height for my milling operation. The follwoing description describes the correct setting. Have a look at the depth settings of the job in FreeCAD, especially Clearence height , Start Depth and Final Depth to crosscheck the correct settings.","title":"Import the gcode"},{"location":"mill_1/#position-your-machine","text":"Move your machine and place it relative to the workpiece where you want to have your x/y zero. Hit xy=0 in the control window you should now have the red circle in x-y view right on the origin of the path: Position the milling cutter right on top of the workpiece. This is the Start Depth - in our case z=+20mm Use g92 z 20 to set the machine position accordingly (and not +25 as I did). Move up in Z, power on the spindle Hit Start in the control pane. The nice thing about grbl is that you can interrupt any command and the machine will (mostly) react instantly - even when e.g. making a long move. Just hit Pause or Stop . This is different from Marlin, where you only can pause or stop after the execution of the current command. Use the feed slider to slow down or speed up the milling procedure. I applied a speed-up as we used the MDF settings for the milling operation but are milling XPS.","title":"Position your machine:"},{"location":"mill_1/#possible-pitfall-why-did-i-use-the-wrong-z-position","text":"Have a look at the y-z view (the first image). I wrongly interpreted the topmost plane of the path as start depth, which is wrong . The path is actually up to clearence plane (z=+25), over to the start position (in x-y) for plunging, fast down to to start depth . So be carefule in interpretation of what you see.","title":"Possible pitfall - why did I use the wrong z position?"},{"location":"mill_1/#machine-at-work","text":"","title":"Machine at work"},{"location":"mill_1/#open-points","text":"Add some holding tags Ramp or hlical plunge Step down in smaller amounts Feel free to dicuss your questions in the related discussion thread","title":"Open points"},{"location":"xlfr53dex/","text":"XLFR5 Export of complex wing geometries We'll be using the following files: Folder Name Comment scripts wingAnalysisLib.py basic worker routines for aerodynamics analysis scripts wingLib.py basic worker routines planes/kissSlope kissSlopeWing.blend the blender file planes/kissSlope xflr5Analysis.py the python script used to generate the input for XFLR5 3d analysis xflr5Analysis.py Target: generate a XFLR5 specific .xml file describing the wing geometry with all its sections generate morphed profile data required by XFLR5 to generate whta is called the foil polar mesh Below the obligatory header, we define the basic geometric data, the leading edge shift as well as the base sections as discussed in more complex wing design . The magic the happens in L.131 - generating the xml sceletton required for XFLR5, adding the subsections according to the definition (l. 132) and writing the xml file (l.137ff): Generating morphed profil data The wing geometry we defined above makes use of morphed profiles for the subsections. For the XFLR5 3D analysis, we need the related 2D profil data to generate what is called the foil polar mesh . Please have a look at Andr\u00e9's tutorial No6 and docs for details. The attentive reader might already have spotted l.66: roundTo=0.05 . This setting is used to reduce the necessary amount of profile data required. A setting of 0.05 means that we use 5% steps for the morphed profiles. The local profile along the subsections use the next available profile along this 5% grid. Execute l.160ff once to generate all the required profile data files in the directory configured in l.165. The result for the AG26 <-> AG14 morph is: Foil polar mesh start XFLR5 in switch to xfoil direct analysis file > open > select all the written .dat files analysis > multi threaded batch analysis select all profiles (and the unmorphed ones, in our case AG25, AG26, and AG14) define a sensible Re range run the batch analysis (this will take a while) After the analysis finished select each profile in the drop down menue hit crtl+u and control the quality of each polar correct if necessary (for the AGxx, I sometimes needed to delete points at \\(\\alpha=-2.5\u00b0\\) and re-calculate with finer angualr steps for \\(\\alpha>0\\) for some polars I added the resulting XFLR5 file (for the kissSlope wing analyis) on github as KDesign_polarMesh.xfl . Import the wing for 3d analyis start XFLR5 open the KDesign_polarMesh.xfl - or generate your own polar for the required Re range file > wing and plane design plane > import plane from xml file Should display the wing: plane > current plane > edit wing Should display all the defined sections: Next: analysis > define analysis select type2 on tab inertia set the palne mass (for the kissSlope 0.9 or 1.3kg) > save in the plane analysis window set the angular region > hit analyze The log output provides interesting information: In my case the analysis had errors, namely at higher \\(alpha\\) . This is where separation occurs and XFLR5 can not find the related operating point in the 2D data: This tells us that starting from \\(\\alpha=10.5\u00b0\\) , separation occurs, luckily from the root region (small span pos values), with the separation growing for increasing \\(alpha\\) . hit close and have a look at the polars the 3D visualization and all the other stuff. See Andr\u00e9's tutorials for more details, especially No 8.","title":"Blender export & 3D analyis"},{"location":"xlfr53dex/#xlfr5","text":"","title":"XLFR5"},{"location":"xlfr53dex/#export-of-complex-wing-geometries","text":"We'll be using the following files: Folder Name Comment scripts wingAnalysisLib.py basic worker routines for aerodynamics analysis scripts wingLib.py basic worker routines planes/kissSlope kissSlopeWing.blend the blender file planes/kissSlope xflr5Analysis.py the python script used to generate the input for XFLR5 3d analysis xflr5Analysis.py Target: generate a XFLR5 specific .xml file describing the wing geometry with all its sections generate morphed profile data required by XFLR5 to generate whta is called the foil polar mesh Below the obligatory header, we define the basic geometric data, the leading edge shift as well as the base sections as discussed in more complex wing design . The magic the happens in L.131 - generating the xml sceletton required for XFLR5, adding the subsections according to the definition (l. 132) and writing the xml file (l.137ff):","title":"Export of complex wing geometries"},{"location":"xlfr53dex/#generating-morphed-profil-data","text":"The wing geometry we defined above makes use of morphed profiles for the subsections. For the XFLR5 3D analysis, we need the related 2D profil data to generate what is called the foil polar mesh . Please have a look at Andr\u00e9's tutorial No6 and docs for details. The attentive reader might already have spotted l.66: roundTo=0.05 . This setting is used to reduce the necessary amount of profile data required. A setting of 0.05 means that we use 5% steps for the morphed profiles. The local profile along the subsections use the next available profile along this 5% grid. Execute l.160ff once to generate all the required profile data files in the directory configured in l.165. The result for the AG26 <-> AG14 morph is:","title":"Generating morphed profil data"},{"location":"xlfr53dex/#foil-polar-mesh","text":"start XFLR5 in switch to xfoil direct analysis file > open > select all the written .dat files analysis > multi threaded batch analysis select all profiles (and the unmorphed ones, in our case AG25, AG26, and AG14) define a sensible Re range run the batch analysis (this will take a while) After the analysis finished select each profile in the drop down menue hit crtl+u and control the quality of each polar correct if necessary (for the AGxx, I sometimes needed to delete points at \\(\\alpha=-2.5\u00b0\\) and re-calculate with finer angualr steps for \\(\\alpha>0\\) for some polars I added the resulting XFLR5 file (for the kissSlope wing analyis) on github as KDesign_polarMesh.xfl .","title":"Foil polar mesh"},{"location":"xlfr53dex/#import-the-wing-for-3d-analyis","text":"start XFLR5 open the KDesign_polarMesh.xfl - or generate your own polar for the required Re range file > wing and plane design plane > import plane from xml file Should display the wing: plane > current plane > edit wing Should display all the defined sections: Next: analysis > define analysis select type2 on tab inertia set the palne mass (for the kissSlope 0.9 or 1.3kg) > save in the plane analysis window set the angular region > hit analyze The log output provides interesting information: In my case the analysis had errors, namely at higher \\(alpha\\) . This is where separation occurs and XFLR5 can not find the related operating point in the 2D data: This tells us that starting from \\(\\alpha=10.5\u00b0\\) , separation occurs, luckily from the root region (small span pos values), with the separation growing for increasing \\(alpha\\) . hit close and have a look at the polars the 3D visualization and all the other stuff. See Andr\u00e9's tutorials for more details, especially No 8.","title":"Import the wing for 3d analyis"},{"location":"xlfr5GettingStarted/","text":"XLFR5 Installation I build the main repo of Andr\u00e9 (the author of xflr5, aka techwinder ). In case of problems you can also try to build the ubuntu specific patched version . svn checkout https://svn.code.sf.net/p/xflr5/code/trunk xflr5-code Install prerequisites apt-get install build-essential mesa-common-dev mesa-utils libgl1-mesa-dev libglu1-mesa-dev qt5-qmake libqt5opengl5-dev Building Note: I initially had an error: cd xflr5-engine/ && ( test -e Makefile || /usr/lib/qt5/bin/qmake -o Makefile /home/alexp/wicht_soft/xflr5-code/xflr5/xflr5-engine/xflr5-engine.pro ) && make -f Makefile Project ERROR: Unknown module(s) in QT: core gui make: *** [Makefile:49: sub-xflr5-engine-make_first] Error 3 Seems to have been fixed by installing libqt5opengl5-dev cd xflr5-code/xflr5 qmake make sudo make install sudo ldconfig Finally, start xlfr5 xlfr5 Export profile data from blender Have a look at the block 'export 4 xlfr5' in the helper file planes/kissSlope/howtoAddMH30.py discussed here : coords=mh30modpk.coords('super',1.0,[0.0,0.0,0.0]) filename=bpy.path.abspath(\"//MH30pk_xlfr5.dat\") wingLib.foilExport(coords,'MH30pk',filename,'xlfr54spaces') allows you to export the desired quality in XLFR5 format. Tutorial notes I followed the tutorial series of Andr\u00e9 (the developer of xlfr5 aka techwinder). The following notes are only meant as comments to the tutorials. Panel/points display (T1: 1:20) right click the foil, 1st entry current foil > set style> set the style for points to points Refine loaded / new designed foil (T1: 1:30) always: design>refine globally to 100-150 panels Design type1 for foils (T1: 3:55) Type1 for foils, type 2 and 4 for planes","title":"Getting started"},{"location":"xlfr5GettingStarted/#xlfr5","text":"","title":"XLFR5"},{"location":"xlfr5GettingStarted/#installation","text":"I build the main repo of Andr\u00e9 (the author of xflr5, aka techwinder ). In case of problems you can also try to build the ubuntu specific patched version . svn checkout https://svn.code.sf.net/p/xflr5/code/trunk xflr5-code Install prerequisites apt-get install build-essential mesa-common-dev mesa-utils libgl1-mesa-dev libglu1-mesa-dev qt5-qmake libqt5opengl5-dev Building Note: I initially had an error: cd xflr5-engine/ && ( test -e Makefile || /usr/lib/qt5/bin/qmake -o Makefile /home/alexp/wicht_soft/xflr5-code/xflr5/xflr5-engine/xflr5-engine.pro ) && make -f Makefile Project ERROR: Unknown module(s) in QT: core gui make: *** [Makefile:49: sub-xflr5-engine-make_first] Error 3 Seems to have been fixed by installing libqt5opengl5-dev cd xflr5-code/xflr5 qmake make sudo make install sudo ldconfig Finally, start xlfr5 xlfr5","title":"Installation"},{"location":"xlfr5GettingStarted/#export-profile-data-from-blender","text":"Have a look at the block 'export 4 xlfr5' in the helper file planes/kissSlope/howtoAddMH30.py discussed here : coords=mh30modpk.coords('super',1.0,[0.0,0.0,0.0]) filename=bpy.path.abspath(\"//MH30pk_xlfr5.dat\") wingLib.foilExport(coords,'MH30pk',filename,'xlfr54spaces') allows you to export the desired quality in XLFR5 format.","title":"Export profile data from blender"},{"location":"xlfr5GettingStarted/#tutorial-notes","text":"I followed the tutorial series of Andr\u00e9 (the developer of xlfr5 aka techwinder). The following notes are only meant as comments to the tutorials. Panel/points display (T1: 1:20) right click the foil, 1st entry current foil > set style> set the style for points to points Refine loaded / new designed foil (T1: 1:30) always: design>refine globally to 100-150 panels Design type1 for foils (T1: 3:55) Type1 for foils, type 2 and 4 for planes","title":"Tutorial notes"},{"location":"zoom_1/","text":"Spotlight on Controller & firmware option B): grbl on Ramps \u2013 dual-end-stop, auto-squaring detailed walk through Step1 \u2013 get the firmware Either download the rar file from Pablo here or this version from Johns gitHub . Unpack / browse into the downloaded stuff The contents should look like this (except the grblSettings_mpcncDualEndStop_bCNC.txt which is not in the Johns repo yet, but can be found in this repo ): doc/images has the wiring description Nothing to be changed with your wiring; just in case you wonder or want to add some extra stuff) Step2 - configure the firmware grbl/config.h In the folder grbl open config.h \u2192 you should be able to configure everything in here. Do not mess around in e.g. limits.c as sometimes proposed as you will be loosing the possibility to easily follow main branch development. Very basics grbl-mega-5x allows you to use 5 (or even 6) axis. We have the axis definitions in line 59ff.: Per axis, there's a definition of the bit (we'll need this later on to be used with the masks) and a name, e.g. line 59/60 for 'X' . For our mpcnc gantry setup, we have 5 axis - originally named x, y, z, a, b in grbl-mx5. These have been renamed to x, y, z, x (cloned x, bit 4) , y (cloned y, bit 5) - I will refer to the latter two as xc and yc. End stop configuration - background Go to line 261. End stops in grbl defaults to normally open (NO). I think the reason is that you don't need to jumper the pins of the unused ports tied to gnd. The mpcnc default for end stops however is (and I think this is sensible, see Ryans arguments ) normally closed (NC). This means using grbl as is, you'll get all end stops firing an alarm when NOT triggered. End stop configuration - $5 not working as intended \u21af We normally would use grbl's configuration command $5=1, which inverts ALL limit pins and could be adapted in the frontend, ess e.g. bCNC settings. Unfortunately this does NOT work (I tried it and alarms I could not get rid of). End stop configuration - solution: invert individual pins Fortunately, there exists (in line 264) #define INVERT_MIN_LIMIT_PIN_MASK, which allows us to invert the necessary pins individually : We'll be using our knowledge about the AXIS_n definition we had learned about previously and set ( Note: this is only necessary if you use your endstops in NC; for NO leave it commented out! ) #define INVERT_MIN_LIMIT_PIN_MASK ((1<<AXIS_1) | (1<<AXIS_2) | (1<<AXIS_4) | (1<<AXIS_5)) This, by the way, also allows you to leave the unused pins (e.g. ZMIN, ZMAX in my case) open. Unfamiliar with bitmasks? Have a read . If you are curious how it's applied, have a read in limits.c line 192ff limits_get_state(). As already stated above: please use config.h to tweak things and do not mess around in .c files whenever possible. Step3 \u2013 flash the firmware Copy the firmware to libraries - start Arduino IDE - at File>Preferences have a look at Sketchbook location for me /home/alexp/Arduino - copy the complete folder grbl in there below the libraries folder Clear EEPROM This is necessary as grbl stores the settings in EEPROM and sometimes left over data might lead to problems. Flash the File>Examples>(all the way down in the menue)EEPROM>eeprom_clear This is done as usual as described by Ryan: how to flash firmware (open the example, compile and upload) FLashback : man, how easy is this - do you remeber the mess in ~year 2k when working with embedded devices from linux ( my tutorial back then in y2k ) Flash grbl - in Arduion IDE: File>open> [whereYouHaveIt]/librarries/grbl/Examples/grblUpload.ino - compile - upload Thats it. After power of/on for the controller board, you should now have a mpcnc with all motors active. Go on to the bCNC tutorial. Feel free to dicuss your questions in the related discussion thread","title":"ZOOM grbl+RAMPS+auto squaring"},{"location":"zoom_1/#spotlight-on","text":"Controller & firmware option B): grbl on Ramps \u2013 dual-end-stop, auto-squaring detailed walk through","title":"Spotlight on"},{"location":"zoom_1/#step1-get-the-firmware","text":"Either download the rar file from Pablo here or this version from Johns gitHub . Unpack / browse into the downloaded stuff The contents should look like this (except the grblSettings_mpcncDualEndStop_bCNC.txt which is not in the Johns repo yet, but can be found in this repo ): doc/images has the wiring description Nothing to be changed with your wiring; just in case you wonder or want to add some extra stuff)","title":"Step1 \u2013 get the firmware"},{"location":"zoom_1/#step2-configure-the-firmware","text":"grbl/config.h In the folder grbl open config.h \u2192 you should be able to configure everything in here. Do not mess around in e.g. limits.c as sometimes proposed as you will be loosing the possibility to easily follow main branch development. Very basics grbl-mega-5x allows you to use 5 (or even 6) axis. We have the axis definitions in line 59ff.: Per axis, there's a definition of the bit (we'll need this later on to be used with the masks) and a name, e.g. line 59/60 for 'X' . For our mpcnc gantry setup, we have 5 axis - originally named x, y, z, a, b in grbl-mx5. These have been renamed to x, y, z, x (cloned x, bit 4) , y (cloned y, bit 5) - I will refer to the latter two as xc and yc. End stop configuration - background Go to line 261. End stops in grbl defaults to normally open (NO). I think the reason is that you don't need to jumper the pins of the unused ports tied to gnd. The mpcnc default for end stops however is (and I think this is sensible, see Ryans arguments ) normally closed (NC). This means using grbl as is, you'll get all end stops firing an alarm when NOT triggered. End stop configuration - $5 not working as intended \u21af We normally would use grbl's configuration command $5=1, which inverts ALL limit pins and could be adapted in the frontend, ess e.g. bCNC settings. Unfortunately this does NOT work (I tried it and alarms I could not get rid of). End stop configuration - solution: invert individual pins Fortunately, there exists (in line 264) #define INVERT_MIN_LIMIT_PIN_MASK, which allows us to invert the necessary pins individually : We'll be using our knowledge about the AXIS_n definition we had learned about previously and set ( Note: this is only necessary if you use your endstops in NC; for NO leave it commented out! ) #define INVERT_MIN_LIMIT_PIN_MASK ((1<<AXIS_1) | (1<<AXIS_2) | (1<<AXIS_4) | (1<<AXIS_5)) This, by the way, also allows you to leave the unused pins (e.g. ZMIN, ZMAX in my case) open. Unfamiliar with bitmasks? Have a read . If you are curious how it's applied, have a read in limits.c line 192ff limits_get_state(). As already stated above: please use config.h to tweak things and do not mess around in .c files whenever possible.","title":"Step2 - configure the firmware"},{"location":"zoom_1/#step3-flash-the-firmware","text":"Copy the firmware to libraries - start Arduino IDE - at File>Preferences have a look at Sketchbook location for me /home/alexp/Arduino - copy the complete folder grbl in there below the libraries folder Clear EEPROM This is necessary as grbl stores the settings in EEPROM and sometimes left over data might lead to problems. Flash the File>Examples>(all the way down in the menue)EEPROM>eeprom_clear This is done as usual as described by Ryan: how to flash firmware (open the example, compile and upload) FLashback : man, how easy is this - do you remeber the mess in ~year 2k when working with embedded devices from linux ( my tutorial back then in y2k ) Flash grbl - in Arduion IDE: File>open> [whereYouHaveIt]/librarries/grbl/Examples/grblUpload.ino - compile - upload Thats it. After power of/on for the controller board, you should now have a mpcnc with all motors active. Go on to the bCNC tutorial. Feel free to dicuss your questions in the related discussion thread","title":"Step3 \u2013 flash the firmware"}]}